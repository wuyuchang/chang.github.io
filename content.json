{"meta":{"title":"Yuchang Wu's blog","subtitle":"Don't forget your original intention","description":"this is a lazy boy, he keep nothing to here","author":"Yuchang Wu","url":"https://blog.afacat.com","root":"/"},"pages":[{"title":"categories","date":"2017-05-25T03:10:22.000Z","updated":"2019-06-28T02:45:15.000Z","comments":true,"path":"categories/index.html","permalink":"https://blog.afacat.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-05-25T03:08:18.000Z","updated":"2019-06-28T02:45:15.000Z","comments":true,"path":"tags/index.html","permalink":"https://blog.afacat.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Config web server with Nginx in Linux for beginner","slug":"web-server","date":"2019-06-28T02:45:15.000Z","updated":"2019-06-28T02:45:15.000Z","comments":true,"path":"2019/06/28/web-server/","link":"","permalink":"https://blog.afacat.com/2019/06/28/web-server/","excerpt":"","text":"We use Debian to finish the demo.Both of below are basic command line, If you are not familiar with command line in Linux, you should learn it first. Update &amp; Upgrade12$ apt-get update$ apt-get upgrade You must curious what’s difference between update and upgrade. updateUsed to re-synchronize the package index files from their sources. The indexes of available packages are fetched from the location(s) specified in /etc/apt/sources.list(5). An update should always be performed before an upgrade or dist-upgrade.upgradeUsed to install the newest versions of all packages currently installed on the system from the sources enumerated in /etc/apt/sources.list(5). Packages currently installed with new versions available are retrieved and upgraded; under no circumstances are currently installed packages removed, nor are packages that are not already installed retrieved and installed. New versions of currently installed packages that cannot be upgraded without changing the install status of another package will be left at their current version. An update must be performed first so that apt-get knows that new versions of packages are available. Htop, Vim &amp; Screen123$ apt-get install htop$ apt-get install vim$ apt-get install screen These packages can improve your effective.htop: [htop][htop] command like [top][top] command, both of these are interactive process viewer for Unix systems. Its help you manage process and monitor resource easy. But [htop][htop] is more convenient than [top][top]. In ‘htop’ you can scroll the list vertically and horizontally to see all processes and complete command lines. In ‘top’ you are subject to a delay for each unassigned key you press (especially annoying when multi-key escape sequences are triggered by accident). ‘htop’ starts faster (‘top’ seems to collect data for a while before displaying anything). In ‘htop’ you don’t need to type the process number to kill a process, in ‘top’ you do. In ‘htop’ you don’t need to type the process number or the priority value to renice a process, in ‘top’ you do. ‘htop’ supports mouse operation, ‘top’ doesn’t ‘top’ is older, hence, more used and tested.From http://hisham.hm/htop/index.php?page=comparison vim: [vim][vim] is almost a proper superset of [vi][vi], everything that is in vi is available in vim. screen: use multiple shell window from a single SSH session Keep a shell active even through network disruptions Disconnect and re-connect to a shell sessions from multiple locations Run a long running process without maintaining an active shell session Usagescreen uses the command ctrl-a that’s the control key and a lowercase “a” as a signal to send commands to screen instead of the shell.start: screencreating: Ctrl-a cswitch: Ctrl-a n for the next window or Ctrl-a p for the previous window.detach: Ctrl-a dreattach: Ctrl-a rlogging: Ctrl-a hlock: Ctrl-a xstop: Ctrl-a k Group &amp; User123456$ groupadd$ groupdel$ useradd$ passwd$ usermod$ userdel useradduser add will auto create group that the name same as user 12345678910$ useradd chang # craete user \"chang\"$ useradd -d /data/projects chang # create user \"chang\" into /data/projects$ useradd -u 999 -g 998 chang # create user with 999 for user id and 998 for group id$ useradd -G admings,webadmin,developers chang #$ useradd -M chang # add user \"chang\" without home directory$ useradd -e 2017-01-01 chang # add user \"chang\" expire at 2017-01-02$ chage -l chang # show/change user or password expire date$ useradd -e 2017-01-01 -f 45 chang # password expire after 2017-01-01$ useradd -c \"Yuchang Wu\" chang # add user with \"Yuchang Wu\" infomation$ tail -1 /etc/passwd # print last 1 line of the file \"/etc/passwd\" the meaning of files that user and group saved /etc/passwd – User account information. /etc/shadow – Secure account information. /etc/group – Group account information. /etc/gshadow – Secure group account information. /etc/login.defs – Shadow password suite configuration.. /etc/passwd format:username:password:uid:gid:userInfo:homeDirectory:shell /etc/group format:groupname:password:gidd:groupMembers usermodfor more detail, to below to see 1$ usermod --help 12$ usermod -G www chang # add www group to chang, Be careful, it will remove all existing groups that user belongs, so always add the '-a' with '-G' to append new groups$ usermod -G www -a chang chownchange file owner 1$ chown -hR www:www /home/www # chang the owner of /homw/www to www user and www group Nginx InstallAs you know, you can install an application with few different methods, below we introduce three common methods to install Nginx. Install from Debian repository1$ apt-get install nginx you can verify the installation through: 1$ nginx -v and you can verify which module you are install through: 1$ nginx -V # Capital and you will get the default configuration like: 123nginx version: nginx/1.6.2TLS SNI support enabledconfigure arguments: --with-cc-opt='-g -O2 -fstack-protector-strong -Wformat -Werror=format-security -D_FORTIFY_SOURCE=2' --with-ld-opt=-Wl,-z,relro --prefix=/usr/share/nginx --conf-path=/etc/nginx/nginx.conf --http-log-path=/var/log/nginx/access.log --error-log-path=/var/log/nginx/error.log --lock-path=/var/lock/nginx.lock --pid-path=/run/nginx.pid --http-client-body-temp-path=/var/lib/nginx/body --http-fastcgi-temp-path=/var/lib/nginx/fastcgi --http-proxy-temp-path=/var/lib/nginx/proxy --http-scgi-temp-path=/var/lib/nginx/scgi --http-uwsgi-temp-path=/var/lib/nginx/uwsgi --with-debug --with-pcre-jit --with-ipv6 --with-http_ssl_module --with-http_stub_status_module --with-http_realip_module --with-http_auth_request_module --with-http_addition_module --with-http_dav_module --with-http_geoip_module --with-http_gzip_static_module --with-http_image_filter_module --with-http_spdy_module --with-http_sub_module --with-http_xslt_module --with-mail --with-mail_ssl_module --add-module=/build/nginx-AZ8ONw/nginx-1.6.2/debian/modules/nginx-auth-pam --add-module=/build/nginx-AZ8ONw/nginx-1.6.2/debian/modules/nginx-dav-ext-module --add-module=/build/nginx-AZ8ONw/nginx-1.6.2/debian/modules/nginx-echo --add-module=/build/nginx-AZ8ONw/nginx-1.6.2/debian/modules/nginx-upstream-fair --add-module=/build/nginx-AZ8ONw/nginx-1.6.2/debian/modules/ngx_http_substitutions_filter_module Note: this type can not get the latest version of the NGINX. Install from Nginx repository Download the key used to sign NGINX packages and repository to the apt program keyring and add it: 12$ wget http://nginx.org/keys/nginx_signing.key$ apt-key add nginx_signing.key Add the “sources” from which NGINX Open Source packages can be obtained: open the /etc/apt/sources.list file in any text editor, for example, vim: 1$ vim /etc/apt/sources.list Append the lines to the file: 12deb http://nginx.org/packages/mainline/debian/ codename nginxdeb-src http://nginx.org/packages/mainline/debian/ codename nginx where:codename is a codename of a Debian release: Version Codename Supported Platforms 7.x wheezy x86_64,i386 8.x jessie x86_64,i386 Install 123$ apt-get remove nginx-common$ apt-get update$ apt-get install nginx list the default module that nginx installed 1$ nginx -V 12345nginx version: nginx/1.11.6built by gcc 4.9.2 (Debian 4.9.2-10)built with OpenSSL 1.0.1t 3 May 2016TLS SNI support enabledconfigure arguments: --prefix=/etc/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib/nginx/modules --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx.lock --http-client-body-temp-path=/var/cache/nginx/client_temp --http-proxy-temp-path=/var/cache/nginx/proxy_temp --http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp --http-scgi-temp-path=/var/cache/nginx/scgi_temp --user=nginx --group=nginx --with-compat --with-file-aio --with-threads --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-mail --with-mail_ssl_module --with-stream --with-stream_realip_module --with-stream_ssl_module --with-stream_ssl_preread_module --with-cc-opt='-g -O2 -fstack-protector-strong -Wformat -Werror=format-security -Wp,-D_FORTIFY_SOURCE=2' --with-ld-opt='-Wl,-z,relro -Wl,-z,now -Wl,--as-needed' You can see the latest version of the NGINX installed to your system. Install from open sourcesAs you see, these above two types to install NGINX is non-configurable, these are pre-build, so they already configure with default value. you can’t add or remove module and configure it. So if you want to add module or 3rd party module and apply latest security patches, I suggest you use this type to install NGINX. the PCRE lirary - required by NGINX core and Rewrite modules and provides support for regular expressions. 123456$ wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.39.tar.gz$ tar -zxf pcre-8.39.tar.gz$ cd pcre-8.39$ ./configure$ make$ sudo make install the zlib library - required by NGINX Gzip module for headers compression. 123456$ wget http://zlib.net/zlib-1.2.8.tar.gz$ tar -zxf zlib-1.2.8.tar.gz$ cd zlib-1.2.8$ ./configure$ make$ sudo make install the OpenSSL library - required by NGINX SSL modules to support the HTTPS protocol. 123456$ wget http://www.openssl.org/source/openssl-1.0.2f.tar.gz$ tar -zxf openssl-1.0.2f.tar.gz$ cd openssl-1.0.2f$ ./configure darwin64-x86_64-cc --prefix=/usr$ make$ sudo make install The header more nginx library - required by NGINX header more nginx module to change the response header information. 12$ wget https://codeload.github.com/openresty/headers-more-nginx-module/tar.gz/v0.32$ tar -zxf v0.32 download the NGINX sources 123$ wget http://nginx.org/download/nginx-1.10.2.tar.gz$ tar zxf nginx-1.10.2.tar.gz$ cd nginx-1.10.2 configure NGINXAdd above that you download module to NGINX, so you can use the module in NGINX. 1$ ./configure --prefix=/usr/local/nginx --sbin-path=/usr/local/nginx/nginx --conf-path=/usr/local/nginx/nginx.conf --pid-path=/usr/local/nginx/nginx.pid --with-pcre=../pcre-8.39 --with-zlib=../zlib-1.2.8 --with-http_ssl_module --add-module=../headers-more-nginx-module-0.32 --with-debug link NGINXNow, you can run nginx with full path – /usr/local/nginx/nginx, and you can browse it with localhost in any browser. But seems not convenient to run nginx with full path every time, so we link the nginx from local to sbin that you can run it without fullpath, just run nginx. 1$ ln -s /usr/local/nginx/nginx /usr/sbin/nginx Now you can run nginx with nginx command without fullpath. 1$ nginx -V Configure webNow, you can access webpage in browser with default page in NGINX via localhost. So, the nginx.conf path is put in where we set during we configure NGINX – /usr/local/nginx/nginx.conf. Let’s look at the file via vim. 12$ cd /usr/local/nginx$ vim nginx.conf go to 35 line through 35 G We drop the unnecessary code, and simplify the code and explain the meaning of the code to below: 123456789server &#123; listen 80; # listening the port, so you access the server with 80 port, this is the default port, so you can access the web server without append :80 server_name localhost; # domain location / &#123; # route, NGINX will receive the URL path, and adapt it with the route, if the path is same with route, then go into the brace block root html; # basic directory where web server in, in this demo, it is in ./html index index.html index.htm; # access it without append the file name if it is index.html or index.htm &#125;&#125; Now, we can configure a server by self, we make the root of the web server in /home/www, and write index.html, then open the nginx.conf to configure the new web server “Hello world” 1234$ mkdir /home/www$ echo \"Hello world\" &gt; index.html$ cd /usr/local/nginx$ vim nginx.conf We append include conf.d/&#42;.conf into nginx.conf at last second line. so we can add the server configure without pollute the origin configure. It will auto add all of the file that have .conf extension into nginx.conf. 12345678server &#123; listen 8080; server_name localhost; location / &#123; root /home/www; index index.html index.htm; &#125;&#125; Then we reload the nginx server with: 1$ nginx -s reload Now, you can access www. http://localhost:8080/ change response headerWe already install the headers-more-nginx-module, so we can configure the response header. Before we configure it, let’s open the developers-tool in google-chrome, and look at the network request, we can get the response headers: For some security reason, we don’t want to show Server information to client, so we can add the configuration to hello_world.conf. 123456789more_set_headers \"Server\" \"\"; # add thisserver &#123; listen 8080; server_name localhost; location / &#123; root /home/www; index index.html index.htm; &#125;&#125; Then reload the nginx server: 1$ nginx -s reload Then we reload the page in browser, and open the network, the Server information already drop. Now, your nginx server is more safer than before you add the server information into response headers. For more detail about the headers-more-nginx-module, see: https://github.com/openresty/headers-more-nginx-module add moduleIf you want to add some module into NGINX that was installed, you have to download the module, then reconfigure NGINX with the module and compile it. Tip123456789$ man order # to see detail of the order$ apt-cache search package # search package$ cat /etc/passwd # show all users$ getent passwd # show all users$ getent group # show all groups$ getent group | grep username$ id username # show username information$ groups username # show which groups does username have$ dpkg-reconfigure tzdate # change timezone Ref:screen https://www.rackaid.com/blog/linux-screen-tutorial-and-how-to/#startinguseradd http://www.tecmint.com/add-users-in-linux/usermod http://www.tecmint.com/usermod-command-examples/permission http://www.tecmint.com/manage-users-and-groups-in-linux/nginx https://www.nginx.com/resources/admin-guide/installing-nginx-open-source/headers-more-nginx-module https://github.com/openresty/headers-more-nginx-module[htop]: https://hisham.hm/htop/index.php[top]: https://linux.die.net/man/1/top[vim]: http://www.vim.org/[vi]: http://ex-vi.sourceforge.net/","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.afacat.com/tags/Linux/"},{"name":"Nginx","slug":"Nginx","permalink":"https://blog.afacat.com/tags/Nginx/"}]},{"title":"微信JSSDK测试接口的Node实现","slug":"wechat-jssdk","date":"2017-07-13T08:30:56.000Z","updated":"2019-06-29T09:35:41.000Z","comments":true,"path":"2017/07/13/wechat-jssdk/","link":"","permalink":"https://blog.afacat.com/2017/07/13/wechat-jssdk/","excerpt":"","text":"做了一个网站，放到线上，用微信打开，点击分享，可是分享后发给朋友的链接卡片是微信默认自带的，如下： 这标题，描述以及图片是默认自带的，丑不说，分享给别人还以为是盗号网站呢，而接入微信的JSSDK后，分享可以自定义内容，如下： 我承认，虽然这分享的标题和内容也并不正经，但这不妨碍我表达**我们可以通过微信JSSDK定义分享内容**，接下来我们将一步一步从零实现JSSDK从后端Node.js的接入。 成为测试公众号开发者登录测试公众号后台首先我们需要在微信公众平台申请测试接口，地址：https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login使用微信扫描登录后，即可来微信公众平台测试账号系统。 成为测试公众号开发者其次在微信公众平台测试账号中，扫描测试号二维码，成为测试公众号的开发者 接口配置信息修改接口配置信息 URL地址必须是你服务器上的地址，此地址要能通过浏览器的地址栏访问到（没有服务器？没关系，一会儿我们搭建一个）假设我这里填写的服务器地址是”http://www.your_server_name.com/wxJssdk&quot; Token你可以随意填写，用作生成签名，（不知道签名？没关系，一会儿会用到这东西的）假设我这里填写的Token是”jegfjaeghfuccawegfgjdbh“ 此时点击提交是会提示配置失败的，因为在提交的时候，微信是会请求你的服务器地址，而你的当前配置的地址并不能访问，所以会提示配置失败。不过别急，我们先来搭建一个简单的Node服务器，让微信能够访问该服务器。 搭建简单的Node服务器我们需要在http://www.your_server_name.com 这个域名上搭建一个服务器，并且曝出一个接口为/wxJssdk 12345678910const express = require('express')const app = express()app.get('/wxJssdk', (req, res) =&gt; &#123; res.send('请求成功了了了了')&#125;)app.listen(80, err =&gt; &#123; if(!err) console.log('connect succeed')&#125;) 现在我们在地址栏中访问http://www.your_server_name.com/wxJssdk ，如果页面显示“请求成功了了了了”，则进入到下一步，如果没有成功的话，检查一下你的服务器是否开启Node服务器，如：node index.js 此时保存微信测试公众号后台的接口配置信息，仍然会提示配置失败，这是因为我们没有按照它的要求返回。 根据微信测试公众号请求信息返回对应内容根据微信公众号开发文档接入指南，微信在请求我们配置的接口时，会带上如下信息 参数 描述 signature 微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数。 timestamp 时间戳 nonce 随机数 echostr 随机字符串 微信服务器会通过GET请求，来请求我们所配置的接口，并带上以上表格的信息，而我们必须按照以下要求，将微信发送的信息进行要求校验，以确保是微信发送的信息，其中校验流程如下： 1）将token、timestamp、nonce三个参数进行字典序排序2）将三个参数字符串拼接成一个字符串进行sha1加密3）开发者获得加密后的字符串可与signature对比，标识该请求来源于微信 12345678910111213141516171819202122232425const express = require('express')const app = express()const sha1 = require('sha1')app.get('/wxJssdk', (req, res) =&gt; &#123; let wx = req.query let token = 'jegfjaeghfuccawegfgjdbh' let timestamp = wx.timestamp let nonce = wx.nonce // 1）将token、timestamp、nonce三个参数进行字典序排序 let list = [token, timestamp, nonce].sort() // 2）将三个参数字符串拼接成一个字符串进行sha1加密 let str = list.join('') let result = sha1(str) // 3）开发者获得加密后的字符串可与signature对比，标识该请求来源于微信 if (result === wx.signature) &#123; res.send(wx.echostr) // 返回微信传来的echostr，表示校验成功，此处不能返回其它 &#125; else &#123; res.send(false) &#125;&#125;) 此时我们重启Node服务器，再次保存接口配置信息即可配置成功。 微信JSSDK使用步骤根据微信JSSDK说明文档，我们需要完成如下： 填写安全域名登录微信公众平台进入“公众号设置”的“功能设置”里填写“JS接口安全域名”，即要调用接口的域名，不包含协议 前端引入JS在需要调用JS接口的页面引入此JS文件，（支持https）：http://res.wx.qq.com/open/js/jweixin-1.2.0.js 填写接口的配置信息12345678wx.config(&#123; debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。 appId: '', // 必填，公众号的唯一标识 timestamp: , // 必填，生成签名的时间戳 nonceStr: '', // 必填，生成签名的随机串 signature: '',// 必填，签名 jsApiList: [] // 必填，需要使用的JS接口列表，所有JS接口列表见附录2&#125;); 调用接口做你前端该做的，调用微信分享接口，或微信提供的其它接口，whatever you need，当然，这并不是我们所要讲的重点，我们接下来要看一下微信的配置信息从哪获取 在Node服务器中生成jssdk所需要的配置信息从上一节可以看到，调用微信JSSDK需要以下信息 appId timestamp nonceStr signature jsApiList 其中： 第1项appId是测试公众号后台的appId，我们已知 第2项时间戳我们也可以自己生成 第3项nonceStr可以随意填写，你可以理解为密钥 第4项signature则需要我们按要求生成 第5项是所需要接口的接口名 生成signature 生成签名之前必须先了解一下jsapi_ticket，jsapi_ticket是公众号用于调用微信JS接口的临时票据。正常情况下，jsapi_ticket的有效期为7200秒，通过access_token来获取。由于获取jsapi_ticket的api调用次数非常有限，频繁刷新jsapi_ticket会导致api调用受限，影响自身业务，开发者必须在自己的服务全局缓存jsapi_ticket 。 为了保证我们appid，appsecret，nonceStr等信息不在前端曝露，我们以下步骤将在服务器上进行操作，以免他人盗用信息获取（注：微信请求有每日次数限制，一旦超出，则无法使用，具体请求次数限制在微信公众号后台中可查看） 生成access_token根据微信开发文档[获取access_token文档说明]，我们需要将微信测试公众号后台的appid和和appsecret以GET的请求方式向https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET 发起请求获取token，请求成功后我们会获得下返回JSON转化的字符串 1&#123;\"access_token\":\"ACCESS_TOKEN\",\"expires_in\":7200&#125; 具体请求代码如下： 123456789const request = require('request')const grant_type = 'client_credential'const appid = 'your app id'const secret = 'your app secret'request('https://api.weixin.qq.com/cgi-bin/token?grant_type=' + grant_type + '&amp;appid=' + appid + '&amp;secret=' + secret, (err, response, body) =&gt; &#123; let access_toekn = JSON.parse(body).access_token&#125;) 获取jsapi_ticket12345678910111213const request = require('request')const grant_type = 'client_credential'const appid = 'your app id'const secret = 'your app secret'request('https://api.weixin.qq.com/cgi-bin/token?grant_type=' + grant_type + '&amp;appid=' + appid + '&amp;secret=' + secret, (err, response, body) =&gt; &#123; let access_toekn = JSON.parse(body).access_token request('https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=' + access_token + '&amp;type=jsapi', (err, response, body) =&gt; &#123; let jsapi_ticket = JSON.parse(body).ticket &#125;)&#125;) 生成签名生成签名的步骤和最开始的/wxJssdk的算法是一致的，具体如下： 12345678910let jsapi_ticket = jsapi_ticket // 上一步从获取的jsapi_ticketlet nonce_str = '123456' // 密钥，字符串任意，可以随机生成let timestamp = new Date().getTime() // 时间戳let url = req.query.url // 使用接口的url链接，不包含#后的内容// 将请求以上字符串，先按字典排序，再以'&amp;'拼接，如下：其中j &gt; n &gt; t &gt; u，此处直接手动排序let str = 'jsapi_ticket=' + jsapi_ticket + '&amp;noncestr=' + nonce_str + '&amp;timestamp=' + timestamp + '&amp;url=' + url// 用sha1加密let signature = sha1(str) 连接后的代码为： 12345678910111213141516171819202122const request = require('request')const grant_type = 'client_credential'const appid = 'your app id'const secret = 'your app secret'request('https://api.weixin.qq.com/cgi-bin/token?grant_type=' + grant_type + '&amp;appid=' + appid + '&amp;secret=' + secret, (err, response, body) =&gt; &#123; let access_toekn = JSON.parse(body).access_token request('https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=' + access_token + '&amp;type=jsapi', (err, response, body) =&gt; &#123; let jsapi_ticket = JSON.parse(body).ticket let nonce_str = '123456' // 密钥，字符串任意，可以随机生成 let timestamp = new Date().getTime() // 时间戳 let url = req.query.url // 使用接口的url链接，不包含#后的内容 // 将请求以上字符串，先按字典排序，再以'&amp;'拼接，如下：其中j &gt; n &gt; t &gt; u，此处直接手动排序 let str = 'jsapi_ticket=' + jsapi_ticket + '&amp;noncestr=' + nonce_str + '&amp;timestamp=' + timestamp + '&amp;url=' + url // 用sha1加密 let signature = sha1(str) &#125;)&#125;) 曝露接口，返回给前端12345678910111213141516171819202122232425262728293031app.post('/wxJssdk/getJssdk', (req, res) =&gt; &#123; const request = require('request') const grant_type = 'client_credential' const appid = 'your app id' const secret = 'your app secret' request('https://api.weixin.qq.com/cgi-bin/token?grant_type=' + grant_type + '&amp;appid=' + appid + '&amp;secret=' + secret, (err, response, body) =&gt; &#123; let access_toekn = JSON.parse(body).access_token request('https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=' + access_token + '&amp;type=jsapi', (err, response, body) =&gt; &#123; let jsapi_ticket = JSON.parse(body).ticket let nonce_str = '123456' // 密钥，字符串任意，可以随机生成 let timestamp = new Date().getTime() // 时间戳 let url = req.query.url // 使用接口的url链接，不包含#后的内容 // 将请求以上字符串，先按字典排序，再以'&amp;'拼接，如下：其中j &gt; n &gt; t &gt; u，此处直接手动排序 let str = 'jsapi_ticket=' + jsapi_ticket + '&amp;noncestr=' + nonce_str + '&amp;timestamp=' + timestamp + '&amp;url=' + url // 用sha1加密 let signature = sha1(str) res.send(&#123; appId: appid, timestamp: timpstamp, nonceStr: nonce_str, signature: signature, &#125;) &#125;) &#125;)&#125;) 前端请求后端接口，获取配置信息获取配置12345678910111213axios.post('/wxJssdk/getJssdk', &#123;url: location.href&#125;).then((response) =&gt; &#123; var data = response.data wx.config(&#123; debug: false, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。 appId: data.appId, // 必填，公众号的唯一标识 timestamp: data.timestamp, // 必填，生成签名的时间戳 nonceStr: data.nonceStr, // 必填，生成签名的随机串 signature: data.signature,// 必填，签名，见附录1 jsApiList: ['onMenuShareTimeline', 'onMenuShareAppMessage'] // 必填，需要使用的JS接口列表，所有JS接口列表见附录2 &#125;);&#125;) 做你想做的，比如，自定义分享1234567891011121314151617181920212223242526272829303132333435if (wx) &#123; axios.post('/wxJssdk/getJssdk', &#123;url: location.href&#125;).then((response) =&gt; &#123; var data = response.data wx.config(&#123; debug: false, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。 appId: data.appId, // 必填，公众号的唯一标识 timestamp: data.timestamp, // 必填，生成签名的时间戳 nonceStr: data.nonceStr, // 必填，生成签名的随机串 signature: data.signature,// 必填，签名，见附录1 jsApiList: ['onMenuShareTimeline', 'onMenuShareAppMessage'] // 必填，需要使用的JS接口列表，所有JS接口列表见附录2 &#125;); wx.ready(function () &#123; wx.onMenuShareTimeline(&#123; title: wxShare.title, desc: wxShare.desc, link: wxShare.link, imgUrl: wxShare.imgUrl &#125;); wx.onMenuShareAppMessage(&#123; title: wxShare.title, desc: wxShare.desc, link: wxShare.link, imgUrl: wxShare.imgUrl &#125;); &#125;) wx.error(function (res) &#123; // config信息验证失败会执行error函数，如签名过期导致验证失败，具体错误信息可以打开config的debug模式查看，也可以在返回的res参数中查看，对于SPA可以在这里更新签名。 &#125;) &#125;)&#125; 至此，后端配置好了，我们已经能够正常使用微信的接口了，但是微信每日接口请求是有上限的，通过2000次/天，因此如果网站上线后，一量当天访问量超过2000次你的接口将失效，而且每次都请求微信接口两次，造成请求时间浪费，所以我们需要将以上获取信息缓存在后端，避免造成接口失效以及多次请求微信后台。 缓存access_token及jsapi_ticket此处直接上代码，利用node_cache包进行缓存 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165const request = require('request')const express = require('express')const app = express()const sha1 = require('sha1')const waterfall = require('async/waterfall')const NodeCache = require('node-cache')const cache = new NodeCache(&#123;stdTTL: 3600, checkperiod: 3600&#125;) //3600秒后过过期app.get('/wxJssdk', (req, res) =&gt; &#123; let wx = req.query // 1）将token、timestamp、nonce三个参数进行字典序排序 let token = 'jegfjaeghfuyawegfgjdbh' let timestamp = wx.timestamp let nonce = wx.nonce // 2）将三个参数字符串拼接成一个字符串进行sha1加密 let list = [token, timestamp, nonce] let result = sha1(list.sort().join('')) // 3）开发者获得加密后的字符串可与signature对比，标识该请求来源于微信 if (result === wx.signature) &#123; res.send(wx.echostr) &#125; else &#123; res.send(false) &#125;&#125;)app.get('/wxJssdk/getJssdk', (req, res) =&gt; &#123; let grant_type = 'client_credential' let appid = 'your app id' let secret = 'your app secret' // appscret let steps = [] // 第一步，获取access_token steps.push((cb) =&gt; &#123; let steps1 = [] // 第1.1步，从缓存中读取access_token steps1.push((cb1) =&gt; &#123; let access_token = cache.get('access_token', (err, access_token) =&gt; &#123; cb1(err, access_token) &#125;) &#125;) // 第1.2步，缓存中有access_token则直接返回，如果没有，则从服务器中读取access_token steps1.push((access_token, cb1) =&gt; &#123; if (access_token) &#123; cb1(null, access_token, 'from_cache') &#125; else &#123; request('https://api.weixin.qq.com/cgi-bin/token?grant_type=' + grant_type + '&amp;appid=' + appid + '&amp;secret=' + secret, (err, response, body) =&gt; &#123; cb1(err, JSON.parse(body).access_token, 'from_server') &#125;) &#125; &#125;) // 第1.3步，如果是新从服务器取的access_token，则缓存起来，否则直接返回 steps1.push((access_token, from_where, cb1) =&gt; &#123; if (from_where === 'from_cache') &#123; console.log(' === 成功从缓存中读取access_token: ' + access_token + ' ===') cb1(null, access_token) &#125; else if (from_where === 'from_server') &#123; cache.set('access_token', access_token, (err, success) =&gt; &#123; if (!err &amp;&amp; success) &#123; console.log(' === 缓存已过期，从服务器中读取access_token: ' + access_token + ' ===') cb1(null, access_token) &#125; else &#123; cb1(err || 'cache设置access_token时，出现未知错误') &#125; &#125;) &#125; else &#123; cb1('1.3获取from_where时，from_where值为空') &#125; &#125;) waterfall(steps1, (err, access_token) =&gt; &#123; cb(err, access_token) &#125;) &#125;) // 第二步，获取ticket steps.push((access_token, cb) =&gt; &#123; let steps1 = [] // 第2.1步，从缓存中读取ticket steps1.push((cb1) =&gt; &#123; let ticket = cache.get('ticket', (err, ticket) =&gt; &#123; cb1(err, ticket) &#125;) &#125;) // 第2.2步，缓存中有ticket则直接返回，如果没有，则从服务器中读取ticket steps1.push((ticket, cb1) =&gt; &#123; if (ticket) &#123; cb1(null, ticket, 'from_cache') &#125; else &#123; request('https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=' + access_token + '&amp;type=jsapi', (err, response, body) =&gt; &#123; cb1(err, JSON.parse(body).ticket, 'from_server') &#125;) &#125; &#125;) // 第2.3步，如果新从服务器取的ticket，则缓存起来，否则直接返回 steps1.push((ticket, from_where, cb1) =&gt; &#123; if (from_where === 'from_cache') &#123; console.log(' === 成功从缓存中读取ticket: ' + ticket + ' ===') cb1(null, ticket) &#125; else if (from_where === 'from_server') &#123; cache.set('ticket', ticket, (err, success) =&gt; &#123; if (!err &amp;&amp; success) &#123; console.log(' === 缓存已过期，从服务器中读取ticket: ' + ticket + ' ==='); cb1(null, ticket) &#125; else &#123; cb1(err || 'cache设置ticket时，出现未知错误') &#125; &#125;) &#125; else &#123; cb1('2.3获取from_where时，from_where值为空') &#125; &#125;) waterfall(steps1, (err, ticket) =&gt; &#123; cb(err, ticket) &#125;) &#125;) // 第三步，生成签名 steps.push((ticket, cb) =&gt; &#123; let jsapi_ticket = ticket let nonce_str = '123456' let timestamp = new Date().getTime() let url = req.query.url let str = 'jsapi_ticket=' + jsapi_ticket + '&amp;noncestr=' + nonce_str + '&amp;timestamp=' + timestamp + '&amp;url=' + url let signature = sha1(str) cb(null, &#123; appId: appid, timestamp: timestamp, nonceStr: nonce_str, signature: signature, ticket: ticket &#125;) &#125;) waterfall(steps, (err, data) =&gt; &#123; if (err) &#123; res.send(&#123;status: 'error', data: err&#125;) &#125; else &#123; res.send(&#123;status: 'success', data: data&#125;) &#125; &#125;)&#125;)app.use('/wxJssdk/public', express.static('public'))app.listen(80, err =&gt; &#123; if(!err) console.log('connect succeed')&#125;)","categories":[],"tags":[{"name":"Front-End","slug":"Front-End","permalink":"https://blog.afacat.com/tags/Front-End/"},{"name":"Node.js","slug":"Node-js","permalink":"https://blog.afacat.com/tags/Node-js/"},{"name":"SDK","slug":"SDK","permalink":"https://blog.afacat.com/tags/SDK/"}]},{"title":"config ThinkPHP support memcache in php5","slug":"config-ThinkPHP-support-memcache-in-php5","date":"2017-01-03T09:23:37.000Z","updated":"2019-06-29T09:37:04.000Z","comments":true,"path":"2017/01/03/config-ThinkPHP-support-memcache-in-php5/","link":"","permalink":"https://blog.afacat.com/2017/01/03/config-ThinkPHP-support-memcache-in-php5/","excerpt":"","text":"This guide is base on Ubuntu &amp; PHP5, so you have to install PHP5 in Ubunut first, but debian is okay. Install Memcached12$ sudo apt-get install memcached$ service memcached start then execute ps aux | grep memcached to check it is running. 1$ ps aux | grep memcached Install Memcache extension for PHPLet’s go to https://pecl.php.net/package-stats.php. download memcache package from https://pecl.php.net/package-stats.php to your home directory. extract it. run phpize to gererate configure, make file. configure make make install 123456$ wget https://pecl.php.net/get/memcache-2.2.7.tgz$ tar zxf memcache-2.2.7.tgz$ phpize$ ./configure$ sudo make$ sudo make install set php.iniappend extension=/path/to/memcache.sophp.ini 1extension=/path/to/memcache.so config ThinkPHPGo into Core/conf/conf.php 123'DATA_CACHE_TYPE' =&gt; 'Memcache','MEMCACHE_HOST' =&gt; 'localhost','MEMCACHE_PORT' =&gt; '11211' restart php-fpm12$ ps aux | grep memcached$ kill pid","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://blog.afacat.com/tags/PHP/"},{"name":"Linux","slug":"Linux","permalink":"https://blog.afacat.com/tags/Linux/"},{"name":"Back-ENd","slug":"Back-ENd","permalink":"https://blog.afacat.com/tags/Back-ENd/"}]},{"title":"Four commonly used form accept type","slug":"Four-commonly-used-form-accept-type","date":"2016-12-20T03:06:46.000Z","updated":"2019-06-29T09:36:47.000Z","comments":true,"path":"2016/12/20/Four-commonly-used-form-accept-type/","link":"","permalink":"https://blog.afacat.com/2016/12/20/Four-commonly-used-form-accept-type/","excerpt":"","text":"The blog based on Node.js server. In front-end, we have several types to send a request to server, most of the time, we use 3 commonly below: application/json application/x-www-form-urlencoded multipart/form-data application/jsonGETclient123456789$.ajax(&#123; url: '/upload', method: 'GET', contentType: 'application/json', data: JSON.stringify(&#123; // must turn to string, whether jQuery will turn to \"x-www-form-urlcoded\" format username: 'username', password: 'password' &#125;)&#125;) Check the request header in network panel in Chrome dev-tool, you will see the request URL turn to http://domain/upload?{&quot;test&quot;:&quot;wuyuchang&quot;,&quot;passowrd&quot;:&quot;chang&quot;}, it’s because GET request always append data to the request URL. 1234Request URL:http://domain/upload?&#123;&quot;test&quot;:&quot;username&quot;,&quot;passowrd&quot;:&quot;password&quot;&#125;Request Method:GETContent-Type:application/json... serverIn server side, you can read the header that client send throw req.headers, and URL throw req.url, then you just compile analysis the parameter after question mark. 123456http.createServer((req, res) =&gt; &#123; const qs = require('querystring') let param = qs.unescape(req.url.split('?')[1]) let json = JSON.parse(param) // ...&#125;).listen(8080) POSTClientFor client, you just change the request method from ‘GET’ to ‘POST’. ServerIn server side, you can’t get content that client send directly, it’s send throw buffer, so you have to receive it by listen it throw req.on(‘data’) 12345678910http.createServer((req, res) =&gt; &#123; let chunk = '' req.on('data', data =&gt; &#123; chunk += data &#125;) req.on('end', err =&gt; &#123; let json = JSON.parse(chunk.toString()) // ... &#125;)&#125;).listen(8080) It’s convenient to get JSON data throw this way. application/x-www-form-urlencodedGETClientSame with above, just change the contenType to ‘application/x-www-form-urlencoded’, the jQuery wouldn’t add contentType automatic if you set method as ‘GET’. server1234http.createServer((req, res) =&gt; &#123; let json = require('url').parse(req.url, true).query // ...&#125;).listen(8080) POSTjQuery set contentType as ‘application/x-www-form-urlencoded’ if you send request throw ‘POST’ method. server1234567891011http.createServer((req, res) =&gt; &#123; let chunk = '' req.on('data', data =&gt; &#123; chunk += data &#125;) req.on('end', err =&gt; &#123; let qs = require('querystring') let json = qs.parse(chunk.toString()) // ... &#125;)&#125;).listen(8080) multipart/form-datamultipart/form-data always used to send a file, of course, you also can send form without file. GETIt’s same with below, the different is that if you send a file to server, the server can’t accept it. POSTClient123456&lt;form action=\"/upload\" method=\"POST\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"text\" name=\"test\" value=\"wuyuchang\"&gt; &lt;input type=\"password\" name=\"pwd\" value=\"chang\"&gt; &lt;input type=\"file\" multiple=\"multiple\" name=\"upload\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"Upload\"&gt;&lt;/form&gt; the request header is different 12345678910111213Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryuyeyXEbnVwhZJcl6Request Payload: ------WebKitFormBoundaryuyeyXEbnVwhZJcl6 Content-Disposition: form-data; name=&quot;test&quot; wuyuchang ------WebKitFormBoundaryuyeyXEbnVwhZJcl6 Content-Disposition: form-data; name=&quot;pwd&quot; chang ------WebKitFormBoundaryuyeyXEbnVwhZJcl6 Content-Disposition: form-data; name=&quot;upload&quot;; filename=&quot;boom.png&quot; Content-Type: image/png the value of boundary is random. ServerIn server side you can compile it, but it’s complex, you can import a package name of ‘formidable’.","categories":[],"tags":[{"name":"Front-End","slug":"Front-End","permalink":"https://blog.afacat.com/tags/Front-End/"},{"name":"Node.js","slug":"Node-js","permalink":"https://blog.afacat.com/tags/Node-js/"}]},{"title":"Principle of Promise/Deferred","slug":"Principle-of-Promise-Deferred","date":"2016-12-09T02:21:08.000Z","updated":"2019-06-29T09:36:15.000Z","comments":true,"path":"2016/12/09/Principle-of-Promise-Deferred/","link":"","permalink":"https://blog.afacat.com/2016/12/09/Principle-of-Promise-Deferred/","excerpt":"","text":"Super simple realize separate call an async and handle result in two files.Assume we have a project base on jQuery, we have to separate call AJAX and handle result in another file. Most of the time, we handle the result with below. 123$.get('url', data =&gt; &#123; //handle data&#125;) But, sometimes, we don’t want to handle it in the moment. Maybe we just want to handle in another file. So we can do below.request.js 123$.get('url', data =&gt; &#123; window.result(data)&#125;) handle.js 123window.result = data =&gt; &#123; // handle result&#125; But, we most of the time, we are not just handle the success result. We also handle error, receiving data.For example. request.js 1234567891011121314$.ajax(&#123; url: 'url', data: 'data', type: 'get', success: data =&gt; &#123; window.deferrd.resolve(data) &#125;, error: err =&gt; &#123; window.defered.error(err) &#125;, complete: notify =&gt; &#123; window.deferred.notify('complete') &#125;&#125;) handle.js 1234567891011121314window.deferred = &#123; //handle success resolve: data =&gt; &#123; console.log(data) &#125;, //handle error error: err =&gt; &#123; console.log(err) &#125;, //handle complete notify: msg =&gt; &#123; console.log(msg) &#125;&#125; use jQuery promise/deferredFortunately, jQuery already implement this, so we just have to do below.request.js 1window.promise = $.get('url') handle.js 12345window.promise.then(data =&gt; &#123; // handle success&#125;, err =&gt; &#123; // handle error&#125;) Promise/AFor show how promise and deferred work, we create a new and simple promise and deferred object, so that you can easy understand it. Promise ObjectHere try to extend EventEmitter module to explain how it work.Promise.class.js 1234567891011121314class Promise extends EventEmitter &#123; then(success, error, progress) &#123; if (typeof success === 'function') &#123; this.once('success', success) &#125; if (typeof error === 'function') &#123; this.once('error', error) &#125; if (typeof progress === 'progress') &#123; // Note, this function will be recall, so here defined the event use 'on' this.on('progress', progress) &#125; &#125;&#125; Here you can see we defined three events after you pass these callback function into it through ‘then’ function.So we defined the events, and we have to trigger it, so that we can execute these callbacks with the result. Below, we defined the Deferred object. Deferred ObjectHere we defined the Deferred, these functions just emit promise, so tell them we finished.Deferred.class.js 1234567891011121314151617class Deferred &#123; this.state = 'unsuccess' this.promise = new Promise() resolve(obj) &#123; this.state = 'success' this.promise.emit('success', obj) &#125; reject(obj) &#123; this.state = 'error' this.promise.emit('error', obj) &#125; progress(obj) &#123; this.state = 'progress' this.promise.emit('progress', obj) &#125;&#125; use Promise &amp; DeferredTo implement this, we create a new Deferred, and we trigger deferred function (progress/end/error) when we finish specific action to tell Deferred that we finished.Then we get promise object, and then we can store it, and call it with callback in another file.So we successful separate call async and get data in two files. 123456789101112131415161718192021222324252627282930let promisify = res =&gt; &#123; let deferred = new Deferred() let result = '' res.on('data', chunk =&gt; &#123; result += chunk deferred.progress(result) &#125;) res.on('end', () =&gt; &#123; deferred.resolve(result) &#125;) res.on('error', () =&gt; &#123; deferred.reject() &#125;) return deferred.promise&#125;global.result = promisify(res)// in another file, this just an example to pass the result to global, so we can easy get the result, in the production, you better to pass the result in other way.global.result.then((result) =&gt; &#123; // success&#125;, (err) =&gt; &#123; // error&#125;, (chunk) =&gt; &#123; // progress console.log(chunk)&#125;) Deferred.all()Do some action after a several of asynchronous finished.Deferred.class.js 12345678910111213141516171819202122class Deferred &#123; // ... all(promises) &#123; let count = promises.length let that = this let results = [] promises.forEach((promise, i) =&gt; &#123; promise.then(data =&gt; &#123; count -- results[i] = data if (count === 0) &#123; that.resolve(results) &#125; &#125;) &#125;, err =&gt; &#123; that.reject(err) &#125;) return this.promise &#125;&#125; Order Run asynchronousRun asynchronous in orderDeferred.class.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const Promise = require('./promise.class')module.exports = class Deferred &#123; constructor() &#123; this.promise = new Promise() &#125; resolve(data) &#123; let promise = this.promise let handler while(handler = promise.queue.shift()) &#123; if (handler &amp;&amp; handler.resolve) &#123; let ret = handler.resolve(data) // if there has next promise, then we interrupt current loop, and set next promise.queue equals current queue if (ret &amp;&amp; ret.isPromise) &#123; ret.queue = promise.queue return &#125; &#125; &#125; &#125; reject(err) &#123; let promise = this.promise let handler while(handler = promise.queue.shift()) &#123; if (handler &amp;&amp; handler.reject) &#123; let ret = handler.reject(err) // if there has next promise, then we interrupt current loop, and set next promise.queue equals current queue if (ret &amp;&amp; ret.isPromise) &#123; ret.queue = promise.queue return &#125; &#125; &#125; &#125; callback(str) &#123; let that = this return (err, file) =&gt; &#123; if (err) &#123; return that.reject(err) &#125; that.resolve(file) &#125; &#125;&#125; promise.class.js 12345678910111213141516171819module.exports = class Promise &#123; constructor() &#123; this.queue = [] this.isPromise = true &#125; then(resolve, reject) &#123; let handler = &#123;&#125; if (typeof resolve === 'function') &#123; handler.resolve = resolve &#125; if (typeof reject === 'function') &#123; handler.reject = reject &#125; this.queue.push(handler) return this &#125;&#125; app.js 1234567891011121314151617181920const Deferred = require('./deferred.class')const fs = require('fs')let action1 = (file, encoding) =&gt; &#123; let deferred = new Deferred() fs.readFile(file, encoding, deferred.callback()) return deferred.promise&#125;let action2 = (file, encoding) =&gt; &#123; let deferred = new Deferred() fs.readFile(file, encoding, deferred.callback()) return deferred.promise&#125;action1('./file1.txt', 'utf8').then(file1 =&gt; &#123; return action2(file1.trim(), 'utf8')&#125;).then(file2 =&gt; &#123; console.log(file2)&#125;)","categories":[],"tags":[{"name":"Front-End","slug":"Front-End","permalink":"https://blog.afacat.com/tags/Front-End/"},{"name":"Node.js","slug":"Node-js","permalink":"https://blog.afacat.com/tags/Node-js/"}]},{"title":"Node.js","slug":"node-js","date":"2016-12-08T12:35:41.000Z","updated":"2019-06-29T09:36:37.000Z","comments":true,"path":"2016/12/08/node-js/","link":"","permalink":"https://blog.afacat.com/2016/12/08/node-js/","excerpt":"","text":"Perform query SQL for server during variety of requests with same result at specific timeBrowser auto cache the result of AJAX for performance, but sometimes we get a special activity which a lot of user will access server for same data at specific time, if we don’t handle it, the server may die. So we can use event queue to handle the problem. 123456789101112let proxy = new events.EventEmitter()let status = 'ready'let select = callback =&gt; &#123; proxy.once('selected', callback) // bind event for every request if (status === 'ready') &#123; status = 'pending' db.select('sql', result =&gt; &#123; // if SQL query finished, proxy.emit('selected', result) // then trigger event status = 'ready' // and recover status &#125;) &#125;&#125; asynchronousAsynchronous is a good object, you can run I/O operate without wait it. It’s a good way to improve the CPU usage rate.Sometimes, we have multiple I/O operates, and these are associated, we want to do some action after all of the I/O operates finished. What can we do? You may do like this below. 1234567fs.readFile(path, 'utf8', (err, template) =&gt; &#123; db.query(sql, (err, data) =&gt; &#123; l10n.get((err, resources) =&gt; &#123; // action &#125;) &#125;)&#125;) It’s easy to do that right? But mention the callback, you run the action in the 3 level callbacks. Think about it, if you have to do 4 or 5 I/O operate, and you do action after all of theses finished. so you may write ‘}) }) }) }) })’, seems painful to maintain the program. Anyway, we don’t do above, that is so stupid. We can make these I/O operate in first level without put an operate in to another callback. Read below. 12345678910111213141516171819202122232425262728let after = (times, callback) =&gt; &#123; let count = 0 let result = &#123;&#125; return (key, value) =&gt; &#123; result[key] = value count++ if (count === times) &#123; callback(results) &#125; &#125;&#125;let emitter = new events.Emitter()let done = after(times, render)emitter.on('done', done)emitter.on('done', other)fs.readFile(template_path, 'utf8', (err, template) =&gt; &#123; emitter.emit('done', 'template', tempalte)&#125;)db.query(sql, (err, data) =&gt; &#123; emitter.emit('done', 'data', data)&#125;)l10n.get((err, resources) =&gt; &#123; emitter.emit('done', 'resources', resources)&#125;) similar with async in waterfall order asynchronoushttps://wuyuchang.github.io/2016/12/09/Principle-of-Promise-Deferred/ smooth123456789let smooth = method =&gt; &#123; return () =&gt; &#123; let deferred = new Deferred() let args = Array.prototype.slice.call(arguments, 0) // transform the arguments to an array args.push(deferred.callback()) // push an parameter, [file, encode, deferred.callback()] method.apply(null, args) // call method, fs.readFile(file, encode, deferred.callback()) return deferred.promise &#125;&#125;","categories":[],"tags":[{"name":"Front-End","slug":"Front-End","permalink":"https://blog.afacat.com/tags/Front-End/"},{"name":"Node.js","slug":"Node-js","permalink":"https://blog.afacat.com/tags/Node-js/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://blog.afacat.com/tags/MongoDB/"}]},{"title":"Math.random骗术-无聊篇","slug":"Math-random骗术-无聊篇","date":"2015-09-23T02:10:00.000Z","updated":"2019-06-29T11:54:48.000Z","comments":true,"path":"2015/09/23/Math-random骗术-无聊篇/","link":"","permalink":"https://blog.afacat.com/2015/09/23/Math-random骗术-无聊篇/","excerpt":"","text":"我觉得今天我运气特好，今天我们来赌一赌，我们来搞个随机数，Math.floor(Math.random() * 10)，如果这个数等于0到7，这个月的饭，我全请了，如果是8或9，你就请一个礼拜成不？于是你想了想，万一我真运气这么好，那不是完了。。于是我追加说，我们来玩5盘，5盘中有一盘0到7，就我请，如果全是8或9，你就请。想想你还是相信概率这东西的，于是和我赌了。。其实，在赌前，我就以经执行了下面这段脚本并测试通过： 然后，我又悄悄的把他清空了。于是结果是： 。。。。。。。。。。。。。你跳楼去了。。从此不相信概率。。。 你们公司有前端妹子？快去骗骗她吧！ 改进：后来，被这个前端妹纸发现了问题，于是我把问题纠正了，去骗下一个妹纸，于是，我在行骗之前，执行了如下脚本： 于是关掉标签页，新开一个，不执行测试，执行了上面的函数。直到现在妹纸还不知道是什么原因。。。 后来妹子一火，你在来试试呀，在来试试我就信，于是我想着应该要我能控制这个随机数，于是我又加了： 当我要赌的时候，我就点击一下页面的右半部分，当怕妹子怀疑的时候，我就点击页面的左半部分。","categories":[],"tags":[{"name":"Front-End","slug":"Front-End","permalink":"https://blog.afacat.com/tags/Front-End/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.afacat.com/tags/JavaScript/"}]},{"title":"浅谈服务端模板到客户端模板","slug":"浅谈服务端模板到客户端模板","date":"2015-09-21T11:10:00.000Z","updated":"2019-06-29T11:51:04.000Z","comments":true,"path":"2015/09/21/浅谈服务端模板到客户端模板/","link":"","permalink":"https://blog.afacat.com/2015/09/21/浅谈服务端模板到客户端模板/","excerpt":"","text":"谈起客户端模板技术，要先从服务端MVC说起。 服务器端MVC当客户通过浏览器访问URL，服务器端会获取到客户端传来的URL并通过路由(router)解析URL到不同的控制器(controller)，再通过模板技术将模板中渲染(render)成到页面(HTML)。 在开发过程中路由可能由服务器配置，可能自己手写，也可能由框架实现。路由通过获取URL，得知要执行哪个控制器，而控制器再去从模型(model)获取数据，模型在去从数据库(database)获取数据，数据库返回数据到模型，再返回至控制器。于是控制器在通过模板技术将从数据库获取的数据替换模板中预定义的内容。最后在返回给客户端浏览器。这是一个完整的前端交互到路由到MVC的流程。 而在模板引擎就是我们的视图(view)部分，接下来，我们来看模板视图。 服务器端模板技术接下来我们先看一段服务器端的模板(handlebars)代码： 123456&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;&lt;ul&gt; &#123;&#123;#names&#125;&#125; &lt;li&gt;&#123;&#123;name&#125;&#125;&lt;/li&gt; &#123;&#123;/names&#125;&#125;&lt;/ul&gt; 以上是一段handlebars的代码， 控制器去从模型中获取以下数据： 1234567var data = &#123; \"title\": \"Story\", \"names\": [ &#123;\"name\": \"Tarzan\"&#125;, &#123;\"name\": \"Jane\"&#125; ] &#125; 本文中不谈及数据是如何获取的。在这里获取到数据后，我们可以通过模板引擎将上面的模板解析成如下的HTML代码： 12345&lt;h1&gt;Story&lt;/h1&gt;&lt;ul&gt; &lt;li&gt;Tarzan&lt;/li&gt; &lt;li&gt;Jane&lt;/ul&gt;&lt;/ul&gt; 而后只需要将此代码以HTML的格式返回给客户端即能正常显示。 这样看来没什么问题，但服务器端模板技术实际上是依赖于控制器，也就是控制器中必须要有访问模板的方法，换句话说，要在客户端浏览器上展示这个渲染出来的页面，需要在服务器端的控制器上去写代码。而且，模板引擎还是后端定的，在后端渲染解析，而维护模板有时还需要前后端共同参与 。因此后端模板在web开发领域中一直是一个前后化分不清的地位。 因此，衍生出了试图前端模板技术，试图将前后端的分工化分的更明细。 客户端(浏览器)端模板技术1、为了更好的化分出前后端开发领域，让HTML完全由前端处理。后端只处理数据及业务逻辑。 2、随着前端交互的复杂性不断提升，无刷新页面数据传输与渲染越发地频繁化，我们发现传统的前端开发方式在ajax数据渲染等方面存在着一个主要问题：繁琐的数据渲染。当前端从后台通过ajax等方式或许到数据后，如果要将这个数据渲染到指定的dom元素中，则需要进行各种字符串拼接工作或者一系列创建元素的工作，还不论细节的问题（单引号双引号问题等），不管是哪一种形式，都是繁琐且费时的。同时，在可读性与维护性上也存在问题。试想，各种循环操作的字符串拼接，元素创建插入，在需要修改时，都需要重新花费不少时间与精力。 就此衍生出了前端模板技术。 浏览器端的模板技术与服务器端的模板技术实现上大体相同，以服务器端上的模板技术的代码为例，如果在客户端使用模板技术，只需要引入模板引擎对应的handlebars.js模板即可使用，而此处的数据，则由前端通过ajax向后端发起请求。而仅仅是这么一点功能，解决了后端渲染模板，前端ajax拼接生成dom的问题。并且ajax是可以缓存的，这在很大程度上减轻了服务器端的压力。但这同时也对前端的技术要求增加。 展望未来(AngularJs)未来的发展趋势是前端后端只靠json数据来进行通信：后端只处理和发送一段Json数据到前端，然后计算和模板渲染都在前端进行。而前端的改动后，形成json数据然后传回到后端。未来趋势就是：后台程序再也不做模板的任何处理。 AngularJS 的作用简单说就是就是把后台的Json值直接用html进行渲染，然后html的操作又直接在形成json传回后台。未来的后台MVC，视图不再是模板了，而是一段结构整齐标准的JSON，而这个JSON作为前台的model直接在AngularJS直接使用。或者说后台的视图是前台的模型，而整个前台就是后台的视图。后台程序再也不做模板的任何处理了。并且AngularJS可以实现双向数据绑定、依赖注入、指令、MVC、模板、模块化开发，使得更像是写后台代码、更规范、更结构化、更可控。 但是，使用AngularJS的话，数据全是通过JSON来进行前后台传输，到了浏览器端才进行数据渲染， 对于SEO，这是一个严重的问题，并且对于庞大的JS库，首次加载时间将更长。对此可以用NodeJS作为一个中转首次加载，模板渲染在NodeJS上实现，之后，由前端实现模板渲染。而这又使前端不得不学习NodeJS。 前端在web开发领域担任的职责将越来越重要，前后端的分工也越来越明细。 引用：http://blog.fens.me/angularjs-route-template/、http://kb.cnblogs.com/page/210862/http://zhidao.baidu.com/link?url=w21FVvMy7By69ylyW3-vLVAdBDBwthHZ8qhSjj67nKE5_h8coDGefDNqUlTwAka8CfY3_LijH_S8EdmNj5h9dYBfuzyp9FfbV5gLm49D9O7&amp;qq-pf-to=pcqq.c2chttp://blog.jobbole.com/65534/","categories":[],"tags":[{"name":"Front-End","slug":"Front-End","permalink":"https://blog.afacat.com/tags/Front-End/"},{"name":"Back-End","slug":"Back-End","permalink":"https://blog.afacat.com/tags/Back-End/"}]},{"title":"一些JavaScript常用方技巧","slug":"一些JavaScript常用方技巧","date":"2015-07-23T03:13:00.000Z","updated":"2019-06-29T11:46:43.000Z","comments":true,"path":"2015/07/23/一些JavaScript常用方技巧/","link":"","permalink":"https://blog.afacat.com/2015/07/23/一些JavaScript常用方技巧/","excerpt":"","text":"1、输入一个正整数n，从1累加到n，返回结果。（如果输入为非正整数，如：小数、0、负数、NaN或其它非数字则返回false） 123function f(n)&#123; return ~~+n == n &amp;&amp; n &gt; 0 ? n * ++n / 2 : false;&#125; 2、用reduce计算数组的和 12345function sum(arr) &#123; return arr.reduce(function(prev, curr) &#123; return prev + curr; &#125;);&#125;; 3、计算平均数（Calculator.average(3,4,5) 返回 4.） 12345678var Calculator = &#123; average: function() &#123; var sum = [].reduce.call(arguments, function(t, n) &#123; return t + n; &#125;, 0); return sum === 0 ? 0 : sum / arguments.length; &#125;&#125;; 4、将数组中的非数字过滤（filter_list([1,2,’aasf’,’1’,’123’,123]) == [1,2,123]） 12345function filter_list(l) &#123; return l.filter(function(v) &#123; return typeof v == 'number' &#125;)&#125; 5、将键值对的对象转化为“=”号相连的字符串（solution({a: 1, b: ‘2’}) // 返回 “a = 1,b = 2”） 12345function solution(pairs)&#123; return Object.keys(pairs) .map(function(k) &#123; return k + ' = ' + pairs[k] &#125;) .join(',');&#125; 6、转数字转换为排名（0=&gt;0, 1=&gt;1st, 2=&gt;2nd, 3=&gt;3rd, 11=&gt;11th, 12=&gt;12th, 13=&gt;13th, 21=&gt;21st, 32=&gt;32nd, 111=&gt;111st, 132=&gt;132nd） 123456789function numberToOrdinal(n) &#123; var e = ['th','st','nd','rd','th']; return n ? n + e[ n % 100 &gt; 10 &amp;&amp; n % 100 &lt; 20 ? 0 : Math.min(n % 10 ,4) ] : \"0\"&#125; 或 12345678function numberToOrdinal(n) &#123; var suffix = \"th\"; if (n == 0) suffix = \"\"; if (n % 10 == 1 &amp;&amp; n % 100 != 11) suffix = \"st\"; if (n % 10 == 2 &amp;&amp; n % 100 != 12) suffix = \"nd\"; if (n % 10 == 3 &amp;&amp; n % 100 != 13) suffix = \"rd\"; return n + suffix;&#125;","categories":[],"tags":[{"name":"Front-End","slug":"Front-End","permalink":"https://blog.afacat.com/tags/Front-End/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.afacat.com/tags/JavaScript/"}]},{"title":"webkit内核下的mouseup后mousemove自动触发问题及解决方法","slug":"webkit内核下的mouseup后mousemove自动触发问题及解决方法","date":"2015-02-28T07:16:00.000Z","updated":"2019-06-29T12:14:10.000Z","comments":true,"path":"2015/02/28/webkit内核下的mouseup后mousemove自动触发问题及解决方法/","link":"","permalink":"https://blog.afacat.com/2015/02/28/webkit内核下的mouseup后mousemove自动触发问题及解决方法/","excerpt":"","text":"如题，就以chrome为代表举例说明遇到mousemove的问题。为body分别绑定onmousedown、onmousemove、onmouseup，并为触发时打印至控制台。代码如下（同学不要忘记body要全屏，并在body上执行操作）： 12345678910111213var body = document.body;body.onmousedown = function() &#123; console.log('down');&#125;body.onmousemove = function(e) &#123; console.log('move');&#125;body.onmouseup = function() &#123; console.log('up');&#125; 先将鼠标移至body区内，刷页面，单击一次body，会发现依次打印了down、up、move，由此可断定是于up后执行的move。我们知道一般我们执行一次点击过程的顺序为：onmousedown、onmousemove、onmouseup、click，而在chrome中却在onmouseup后执行了一次onmousemove，此bug说不清是否有意而为之，但对于开发来说是没有必要的，因此我们就要避免此问题的出现，以免莫名多执行了一次onmousemove。 解决方法不高级，也就是判断是否真的移动了，从而判断是否执行onmousemove触发的函数。 1234567891011121314151617181920var body = document.body, obj = &#123;&#125;;body.onmousedown = function(e) &#123; console.log('down');&#125;body.onmousemove = function(e) &#123; if (e.pageX === obj.x &amp;&amp; e.pageY === obj.y) &#123; return false; &#125; console.log('move');&#125;// 前面说过是在onmouseup后执行onmousemove，因此在这更改x,y更合理body.onmouseup = function(e) &#123; obj.x = e.pageX; obj.y = e.pageY; console.log('up');&#125; 会发现，onmousemove恢复正常。单击依次打印：down、up。 问题就此解决。","categories":[],"tags":[{"name":"Front-End","slug":"Front-End","permalink":"https://blog.afacat.com/tags/Front-End/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.afacat.com/tags/JavaScript/"}]},{"title":"userAgent判断浏览器内核,系统版本,移动设备等","slug":"userAgent判断浏览器内核-系统版本-移动设备等","date":"2015-01-25T09:17:00.000Z","updated":"2019-06-29T11:00:27.000Z","comments":true,"path":"2015/01/25/userAgent判断浏览器内核-系统版本-移动设备等/","link":"","permalink":"https://blog.afacat.com/2015/01/25/userAgent判断浏览器内核-系统版本-移动设备等/","excerpt":"","text":"识别浏览器呈现引擎为了不在全局作用域中添加多余变量，这里使用单例模式（什么是单例模式？）来封装检测脚本。检测脚本的基本代码如下所示： 12345678910111213141516var client = function() &#123; var engine = &#123; ie: 0, gecko: 0, webkit: 0, khtml: 0, opera: 0, // 具体的版本号 ver: null &#125;; return &#123; engine: engine &#125;&#125;(); 这里声明了一个名为client的全局变量，用于保存相关信息。匿名函数内部定义了一个局部变量engine，它是一个包含默认设置的对象字面量。在这个对象字面量中，每个呈现引擎都对应着一个属性，属性的默认值是0。如果检测到了哪个呈现引擎，那么就以浮点数值形式将该引擎的版本号写入相应属性。 要识别Opera，必须得检测window.opera对象。Opera5及更高版本中都有这个对象，用于保存与浏览器相关的标识信息以及与浏览器直接交互。在Opera7.6及更高版本中，调用version()方法可以返回一个表示浏览器版本的字符串，而这也是确定Opera版本的最佳方式。要检测更早的Opera，可以直接检测用户代理字符串，因为那些版本还不支持隐藏身份。不过2007底Opera的最高版本已经是9.5了，所以不太可能有人还使用7.6之前的版本。那么，检测呈现引擎的代码的第一步，就是编写如下代码： 1234if (window.opera) &#123; engine.ver = window.opera.version(); engine.opra = parseFloat(engine.ver);&#125; 接下来检测的引擎是webkit，因为webkit的用户代理字符串中包含“Gecko”和“KHTML”这两个子字符串，所以如果先检测它们，都可能会得出错误的结论。不过，Webkit的用户代理字符串中的“AppleWebkit”是独一无二的，因此检测这个字符串是最合适的。下面就是检测该字符串的示例代码： 12345678var ua = navigator.userAgent; if (window.opera) &#123; engine.ver = window.opera.version(); engine.opra = parseFloat(engine.ver); &#125; else if (/AppleWebkit\\/(\\S+)/i.test(ua)) &#123; engine.ver = RegExp['$1']; engine.webkit = parseFloat(engine.ver); &#125; 接下来要测试的引擎是KHTML。同样，KHTML的用户代理字符串中也包含“Gecko”，因此在排除KHTML之前，我们无法准确检测基于Gecko的浏览器。KHTML的版本号与Webkit的版本号在用户代理字符串中的格式差不多，因此可以使用类似的正则表达式。此外，由于Konquerror 3.1及更早版本中不包含KHTML的版本，故而就要使用Konqueror的版本来代替。下面就是相应的检测代码。 1234567891011121314var ua = navigator.userAgent; if (window.opera) &#123; // 检测opera engine.ver = window.opera.version(); engine.opra = parseFloat(engine.ver); &#125; else if (/AppleWebkit\\/(\\S+)/i.test(ua)) &#123; // 检测webkit engine.ver = RegExp['$1']; engine.webkit = parseFloat(engine.ver); &#125; else if (/KHTML\\/(\\S+)/i.test(ua) || /Konqueror\\/([^;]+)/i.test(ua)) &#123; // 检测khtml engine.ver = RegExp['$1']; engine.khtml = parseFloat(engine.ver); &#125; 在排除了Webkit和KHTML之后，就可以准确地检测Gecko了。但是，在用户代理字符串中，Gecko的版本号不会出现在字符串“Gecko”的后面，而是会出现在字符串“rv:”的后面。这样，我们就必须使用一个比前面复杂一些的正则表达式，如下所示。 123456789101112131415161718var ua = navigator.userAgent; if (window.opera) &#123; // 检测opera engine.ver = window.opera.version(); engine.opra = parseFloat(engine.ver); &#125; else if (/AppleWebkit\\/(\\S+)/i.test(ua)) &#123; // 检测webkit engine.ver = RegExp['$1']; engine.webkit = parseFloat(engine.ver); &#125; else if (/KHTML\\/(\\S+)/i.test(ua) || /Konqueror\\/([^;]+)/i.test(ua)) &#123; // 检测khtml engine.ver = RegExp['$1']; engine.khtml = parseFloat(engine.ver); &#125; else if (/rv:([^\\)]+)\\) Gecko\\/\\d&#123;8&#125;/i.test(ua)) &#123; // 检测gecko engine.ver = RegExp['$1']; engine.gecko = parseFloat(engine.ver); &#125; 最后一个要检测的就是IE了。IE的版本号们于字符串“MSIE”的后面、一个分号的前面，因此相应的正则表达式非常简单，如下所示： 12345678910111213141516171819202122var ua = navigator.userAgent; if (window.opera) &#123; // 检测opera engine.ver = window.opera.version(); engine.opra = parseFloat(engine.ver); &#125; else if (/AppleWebkit\\/(\\S+)/i.test(ua)) &#123; // 检测webkit engine.ver = RegExp['$1']; engine.webkit = parseFloat(engine.ver); &#125; else if (/KHTML\\/(\\S+)/i.test(ua) || /Konqueror\\/([^;]+)/i.test(ua)) &#123; // 检测khtml engine.ver = RegExp['$1']; engine.khtml = parseFloat(engine.ver); &#125; else if (/rv:([^\\)]+)\\) Gecko\\/\\d&#123;8&#125;/i.test(ua)) &#123; // 检测gecko engine.ver = RegExp['$1']; engine.gecko = parseFloat(engine.ver); &#125; else if (/MSIE ([^;]+/i.test(ua))/) &#123; // 检测ie engine.ver = RegExp['$1']; engine.ie = parseFloat(engine.ver); &#125; 识别浏览器大多数情况下，识别了浏览器的呈现引擎就足以为我们采取正确的操作提供依据了。可是，只有呈现引擎还不能说明存在所需的JavaScript功能。苹果公司的Safari浏览器和谷歌公司的Chrome浏览器都使用Webkit引擎，但它们的JavaScript引擎却不一样。在这两款浏览器中，client.webkit都会返回非0值，但仅知道这一点恐怕还不够。对于它们，有必要像下面这样为client对象再添加一些新属性。 123456789101112131415161718192021222324252627282930var client = function() &#123; var engine = &#123; ie: 0, gecko: 0, webkit: 0, khtml: 0, opera: 0, // 具体的版本号 ver: null &#125;; var browser = &#123; // 浏览器 ie: 0, firefox: 0, safari: 0, konq: 0, opera: 0, chrome: 0, // 具体的版本号 ver: null &#125;; return &#123; engine: engine, browser: browser &#125;&#125;(); 代码中又添加了browser，用于保存每个主要浏览器的属性。与engine变量一样，除了当前使用的浏览器，其它属性的值将保持为0。如果是当前使用的浏览器，则这个属性中保存的是浮点数值形式的版本号。同样，ver属性中必要时将会包含字符串形式的浏览器完整版本号。由于大多数浏览器与呈现引擎密切相关，所以下面示例中检测浏览器代码与检测呈现引擎的代码是混合在一起的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283var client = function() &#123; var engine = &#123; ie: 0, gecko: 0, webkit: 0, khtml: 0, opera: 0, // 具体的版本号 ver: null &#125;; var browser = &#123; // 浏览器 ie: 0, firefox: 0, safari: 0, konq: 0, opera: 0, chrome: 0, // 具体的版本号 ver: null &#125;; var ua = navigator.userAgent; if (window.opera) &#123; // 检测opera engine.ver = browser.ver = window.opera.version(); engine.opra = browser.opera = parseFloat(engine.ver); &#125; else if (/AppleWebkit\\/(\\S+)/i.test(ua)) &#123; // 检测webkit engine.ver = RegExp['$1']; engine.webkit = parseFloat(engine.ver); // 检测Chrome/safari与其对应的版本 if (/Chrome\\/(\\S+)/i.test(ua)) &#123; browser.ver = RegExp['$1']; browser.chrome = parseFloat(browser.ver); &#125; else if (/Version\\/(\\S+)/i.test(ua)) &#123; browser.ver = RegExp['$1']; browser.safari = parseFloat(browser.ver); &#125; else &#123; // 当检测不出Safari版本时，可大致确定safari的版本 var safariVersion = 1; if (engine.webkit &lt; 100) &#123; safariVersion = 1; &#125; else if (engine.webkit &lt; 312) &#123; safariVersion = 1.2; &#125; else if (engine.webkit &lt; 412) &#123; safariVersion = 1.3; &#125; else &#123; safariVersion = 2; &#125; browser.safari = browser.ver = safariVersion; &#125; &#125; else if (/KHTML\\/(\\S+)/i.test(ua) || /Konqueror\\/([^;]+)/i.test(ua)) &#123; // 检测khtml engine.ver = browser.ver = RegExp['$1']; engine.khtml = browser.konq = parseFloat(engine.ver); &#125; else if (/rv:([^\\)]+)\\) Gecko\\/\\d&#123;8&#125;/i.test(ua)) &#123; // 检测gecko engine.ver = RegExp['$1']; engine.gecko = parseFloat(engine.ver); // 确定是不是Firefox if (/Firefox\\/(\\S)+/i.test(ua)) &#123; browser.ver = RegExp['$1']; browser.firefox = parseFloat(browser.ver); &#125; &#125; else if (/MSIE ([^;]+/i.test(ua))/) &#123; // 检测ie engine.ver = browser.ver = RegExp['$1']; engine.ie = browser.ie = parseFloat(engine.ver); &#125; return &#123; engine: engine, browser: browser &#125;&#125;(); 识别浏览器平台——操作系统很多时候，只要知道呈现引擎足以编写出适当的代码了。但在某些条件下，平台可能是必须关注的问题。那些具有各个平台的浏览器（如Safari、Firefox、Opera）在不同的平台下可能会有不同的问题。目前的三大主流平台是Windows、Mac和Unix（包括各种Linux）。为了检测这些平台，还需要像下面这样添加一个新对象。 123456789101112131415161718192021222324252627282930313233343536var client = function() &#123; var engine = &#123; ie: 0, gecko: 0, webkit: 0, khtml: 0, opera: 0, // 具体的版本号 ver: null &#125;; var browser = &#123; // 浏览器 ie: 0, firefox: 0, safari: 0, konq: 0, opera: 0, chrome: 0, // 具体的版本号 ver: null &#125;; var system = &#123; win: false, mac: false, xll: false &#125;; return &#123; engine: engine, browser: browser &#125;&#125;(); 在确定平台时，检测navigator.platform要比检测用户代理字符串更简单，后者在不同浏览器中会给出不同平台的信息。而navigator.platform属性可能的值包括“Win32”、“Win64”、“MacPPC”、“MacIntel”、“Xll”和“Linux i686”，这些值在不同浏览器中都是一致的。检测平台的代码非常直观，如下所示： 1234var p = navigator.platform;system.win = p.indexOf('Win') == 0;system.mac = p.indexOf('Mac') == 0;system.xll = (p.indexOf('Xll') == 0 || p.indexOf('Linux') == 0); 识别Window操作系统在Windows下台下，还可以从用户代理字符串中进一步以得具体的操作系统信息。在WIndows XP之前，Windows有两种版本，分别针对家庭版用户和商业用户。针对家庭用户的版本分别是Windows 95、98和Windows ME。而针对商业用户的版本则一直叫做Windows NT，最后由于市场原因改名为Windows 2000。这两个产品后来又合并成一个由Windows NT发展而来的公共的代码基，代表产品就是Winodws XP。随后，微软在Windows XP基础上又构建Windows Vista。 只有了解这些信息，才能搞清楚用户代理字符串中Winodws操作系统具体版本。下表列出了不同浏览器在表示不同Windows操作系统时给出的不同字符串。 windows版本 IE4+ Gecko Opera Webkit 95 “Windows 95” “Win95” “Windows 95” n/a 98 “Winodws 98” “Win98” “Windows 98” n/a NT 4.0 “Windows NT” “WinNT4.0” “windows NT 4.0” n/a 2000 “Windows NT 5.0” “Windows NT 5.0” “Windows NT 5.0” n/a ME “Win 9x 4.90” “Win 9x 4.90” “Win 9x 4.90” n/a XP “Windows NT 5.1” “Windows NT 5.1” “Windows NT 5.1” “Windows NT 5.1” Vista “Windows NT 6.0” “Windows NT 6.0” “Windows NT 6.0” “Windows NT 6.0” 7 “Windows NT 6.1” “Windows NT 6.1” “Windows NT 6.1” “Windows NT 6.1” 8 “Windows NT 6.2” “Windows NT 6.2” “Windows NT 6.2” “Windows NT 6.2” 代理字符串中的Windows操作系统版本表示方法各异，因此检测代码并不十分直观。好在，从Windows 2000开始，表示操作系统的字符串大部分都还相同，只有版本号有变化。为了检测不同的Windows操作系统，必须使用正则表达式。 第一步就是匹配Winodws 95和Windows 98这两个字符串。对这两个字符串，只有Gecko与其它浏览器不同，即没有”dows”，而且”win”与版本号之间没有空格。要匹配这个模式，可以使用下面这个简单的正则表达式： 1/Win(?:dows )?([^do]&#123;2&#125;)/i 这个正则表达式中捕获的数组会返回操作系统的版本。由于版本可能是任何两个字符编码（例如 95、98、9x、NT、ME及XP），因此要使用两个非空空格字符。 Gecko在表示Windows NT时会在末尾添加“4.0”，与其查找实际字符串，不如像现在这样查找小数值更合适。 1/Win(?:dows )?([^do]&#123;2&#125;)(\\d+\\.\\d+)?/i 这样，正则表达式中就包含了第二个捕获组，用于取得NT的版本号。由于该版本号对于Windows 95、98而言是不存在的，所以必须设置为可选。这个模式与Opera表示Windows NT的字符串之间唯一的区别，就是“NT”与“4.0”之间的空格，这在模式中很容易添加。 1/Win(?:dows )?([^do]&#123;2&#125;)\\s+(\\d+\\.\\d+)?/i 经过一番修改后，这个正则表达式也可以成功匹配Windows ME、Windows XP和Windows Vista的字符串了。具体来说，第一个捕获数组将会匹配95、98、9x、NT、ME或XP。第二个捕获数组则只针对Windows ME及所有WIndows NT的变体。这个信息作为具体的操作系统信息保存在system.win属性中，如下所示： 123456789101112131415161718if (system.win) &#123; if (/Win(?:dows )?([^do]&#123;2&#125;)\\s?(\\d+\\.\\d+)?/i.test(ua)) &#123; if (RegExp['$1'] == 'NT') &#123; switch (RegExp['$2']) &#123; case '5.0': system.win = '2000'; break; case '5.1': system.win = 'XP'; break; case '6.0': system.win = 'Vista'; break; case '6.1': system.win = '7'; break; case '6.2': system.win = '8'; break; default: system.win = 'NT'; break; &#125; &#125; else if (RegExp['$1'] == '9x') &#123; system.win = 'ME'; &#125; else &#123; system.win = RegExp['$1']; &#125; &#125; &#125; 识别移动设备2006到2007年，移动设备中Web浏览器的应用呈爆炸式增长。四大主要浏览器都推出了手机版和其它设备中运行的版本。要检测相应的设备，第一步是为要检测的所有移动设备添加属性，如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var client = function() &#123; var engine = &#123; ie: 0, gecko: 0, webkit: 0, khtml: 0, opera: 0, // 具体的版本号 ver: null &#125;; var browser = &#123; // 浏览器 ie: 0, firefox: 0, safari: 0, konq: 0, opera: 0, chrome: 0, // 具体的版本号 ver: null &#125;; var system = &#123; win: false, mac: false, xll: false, // 移动设备 iphone: false, ipod: false, ipad: false, ios: false, android: false, nokiaN: false, winMobile: false &#125;; return &#123; engine: engine, browser: browser, system: system &#125;&#125;(); 然后，通过简单地检测字符串“iPhone”、”iPod”和”iPad”就可以分别设置相应属性的值了。 123system.iphone = ua.indexOf('iPhone') &gt; -1;system.ipod = ua.indexOf('iPod') &gt; -1;system.ipad = ua.indexOf('iPad') &gt; -1; 除了知道IOS设备，最好还知道IOS的版本号。在IOS之前，用户代理字符串中只包含“CPU like Mac OS”，后来iPhone中又改成“CPU iPhone OS 3_0 like Mac OS X”，iPad又改成“CPU OS 3_2 like Mac OS X”。也就是说，检测IOS需要正则表达式反映这些变化。 12345678// 检测ios版本if (system.mac &amp;&amp; ua.indexOf('Mobile') &gt; -1) &#123; if (/CPU (?:iPhone )?OS (\\d+_\\d+)/i.test(ua)) &#123; system.ios = parseFloat(RegExp['$1'].replace('_', '.')); &#125; else &#123; system.ios = 2; // 不能真正检测出来，所以只能猜测 &#125;&#125; 检测系统是不是Mac OS、字符串中是否存在“Mobile”，可以保证无论是什么版本，system.ios中都不会是0。然后，再使用正则表达式确定是否存在IOS的版本号。如果有，将system.ios设置为表示版本号的浮点值；否则，将版本号设置为2。（因为没有办法确定到底是什么版本，所以设置为更早的版本比较稳妥） 检测Android版本操作系统也很简单，也就是搜索字符串“Android”并取得紧随其后的版本号。 1234// 检测android版本if (/Android (\\d+\\.\\d+)/i.test(ua)) &#123; system.android = parseFloat(RegExp['$1']);&#125; 由于所有的Android都有版本值，因此使用这个正则表达式可以精确的检测所有版本，并将system.android设置为正确的值。 诺基亚N系统手机使用的也是Webkit，其用户代理字符串与其它基于webkit的手机很相似。虽然诺基亚N系列手机在用户代理字符串中声称使用的是“safari”，但实际上并不是safari，尽管确实是基于webkit引擎。只要使用下面检测一下用户代理字符串中是否存在“NokiaN”，就足以确定是不是该系列的手机了。 12// 检测nokiasystem.nokiaN = ua.indexOf('NokiaN') &gt; -1; 最后一种主要的移动设备平台是Windows Mobile（也称Windows CE），用于Pocket PC和Smartphone中。由于从技术上说这些平台都属于Windows平台，因此Windows平台和操作系统都会返回正确的值。对于Windows Mobile 5.0及以前的版本，这两种设备的用户代理字符串非常相似，如下所示： Mozilla/4.0 (compatible; MSIE 4.01; Windows CE; PPC; 240x320) Mozilla/4.0 (compatible; MSIE 4.01; Windows CE; Smartphone; 176x220) 这一个来自Pocket PC中的移动Internet Explorer 4.01，第二个来自Smartphone中的同一个浏览器。当Windows操作系统检测脚本检测到这两个字符串时，system.win将被设置成”CE”，因此在检测Windows Mobile时可以使用这个值： 12// 检测Windows Mobilesystem.winMobile = (system.win == 'CE'); 不建议测试字符串中的“PPC”或“Smartphone”，因为在Windows Mobile 5.0以后版本的浏览器中，这些记号已经被移除了。不过，一般情况下，只知道这某个设备使用的是Windows Mobile也就足够了。 Windows Phone 7的用户代理字符串稍有改进，基本格式如下： Mozilla/4.0 (compatible; MSIE 7.0; Windows Phone OS 7.0; Trident/3.1; IEMobile/7.0) Asus;Galaxy6 其中，Windows操作符的标签符与已往完全不同，因此在这个用户代理中，clinet.system.win等于”ph”。从中可以取得有关系统的更多信息： 123456789// 检测Windows Mobileif (system.win == 'CE') &#123; system.winMobile = system.win;&#125; else if (system.win == 'Ph') &#123; if (/Windows Phone OS (\\d+.\\d+)/i.test(ua)) &#123; system.win = 'Phone'; system.winMobile = parseFloat(RegExp['$1']); &#125;&#125; 如果system.win的值是”CE”，就说明是老版本的Windows Mobile，因此system.winMobile会被设置为相同的值（只能知道这个信息）。如果system.win的值是“Ph”，那么这个设置就可能是Windows Phone7或更新版本。因此就用正则表达式来测试格式并提取版本号，将system.win的值重置为”Phone”，而将system.winMobile设置为版本号。 识别游戏系统除了移动设备之外，视频游戏系统中的Web浏览器也开始日益普及。Wii中的浏览器实际上是定制版的Opera，是专门为Wii Remote设计的。Playstation的浏览器是自己开发的，没有基于前面提到的任何呈现引擎。这两个中的用户代理字符串如下所示： Opera/9.10 (Nintendo Wii; U; ; 1621; en) Mozilla/5.0 (PLAYSTATION 3; 2.00) 在检测这些设置以前，我们必须先为client.system中添加适当的属性，如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var client = function() &#123; var engine = &#123; ie: 0, gecko: 0, webkit: 0, khtml: 0, opera: 0, // 具体的版本号 ver: null &#125;; var browser = &#123; // 浏览器 ie: 0, firefox: 0, safari: 0, konq: 0, opera: 0, chrome: 0, // 具体的版本号 ver: null &#125;; var system = &#123; win: false, mac: false, xll: false, // 移动设备 iphone: false, ipod: false, ipad: false, ios: false, android: false, nokiaN: false, winMobile: false, // 游戏系统 wii: false, ps: false &#125;; return &#123; engine: engine, browser: browser, system: system &#125;&#125;(); 检测前述游戏系统的代码如下： 123// 检测游戏系统system.wii = ua.indexOf('Wii') &gt; -1;system.ps = /playstation/i.test(ua); 完整的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149var client = function() &#123; var engine = &#123; ie: 0, gecko: 0, webkit: 0, khtml: 0, opera: 0, ver: null &#125;; var browser = &#123; ie: 0, firefox: 0, safari: 0, konq: 0, opera: 0, chrome: 0, ver: null &#125;; var system = &#123; win: false, mac: false, xll: false, iphone: false, ipoad: false, ipad: false, ios: false, android: false, nokiaN: false, winMobile: false, wii: false, ps: false &#125;; var ua = navigator.userAgent; // 检测浏览器呈现引擎 if (window.opera) &#123; engine.ver = browser.ver = window.opera.version(); engine.opera = browser.opera = parseFloat(engine.ver); &#125; else if (/AppleWebkit\\/(\\S+)/i.test(ua)) &#123; engine.ver = RegExp['$1']; engine.webkit = parseFloat(engine.ver); // 确定是Chrome还是Safari if (/Chrome\\/(\\S+)/i.test(ua)) &#123; browser.ver = RegExp['$1']; browser.chrome = parseFloat(browser.ver); &#125; else if (/Version\\/(\\S+)/i.test(ua)) &#123; browser.ver = RegExp['$1']; browser.safari = parseFloat(browser.ver); &#125; else &#123; // 近似地确定版本号 var safariVersion = 1; if (engine.webkit &lt; 100) &#123; safariVersion = 1; &#125; else if (engine.webkit &lt; 312) &#123; safariVersion = 1.2; &#125; else if (engine.webkit &lt; 412) &#123; safariVersion = 1.3; &#125; else &#123; safariVersion = 2; &#125; browser.safari = browser.safari = safariVersion; &#125; &#125; else if (/KHTML\\/(\\S+)/i.test(ua) || /Konqueror\\/([^;]+)/i.test(ua)) &#123; engine.ver = browser.ver = RegExp['$1']; engine.khtml = browser.konq = parseFloat(engine.ver); &#125; else if (/rv:([^\\)]+)\\) Gecko\\/\\d&#123;8&#125;/i.test(ua)) &#123; engine.ver = RegExp['$1']; engine.gecko = parseFloat(engine.ver); // 确定是不是Firefox if (/Firefox\\/(\\S+)/i.test(ua)) &#123; engine.ver = browser.ver = RegExp['$1']; engine.firefox = parseFloat(browser.ver); &#125; &#125; else if (/MSIE ([^;]+)/i.test(ua)) &#123; engine.ver = browser.ver = RegExp['$1']; engine.ie = browser.ie = parseFloat(engine.ver); &#125; // 检测平台 var p = navigator.platform; system.win = p.indexOf('Win') == 0; system.mac = p.indexOf('Mac') == 0; system.xll = (p.indexOf('Xll') == 0 || p.indexOf('Linux') == 0); // 检测Windows操作系统 if (system.win) &#123; if (/Win(?:dows )?([^do]&#123;2&#125;)\\s?(\\d+\\.\\d+)?/.test(ua)) &#123; if (RegExp['$1'] == 'NT') &#123; switch(RegExp['$2']) &#123; case '5.0': system.win = '2000'; break; case '5.1': system.win = 'XP'; break; case '6.0': system.win = 'Vista'; break; case '6.1': system.win = '7'; break; case '6.2': system.win = '8'; break; default: system.win = 'NT'; break; &#125; &#125; else if (RegExp['$1'] == '9x') &#123; system.win = 'ME'; &#125; else &#123; system.win = RegExp['$1']; &#125; &#125; &#125; // 移动设备 system.iphone = ua.indexOf('iPhone') &gt; -1; system.ipod = ua.indexOf('iPod') &gt; -1; system.ipad = ua.indexOf('iPad') &gt; -1; system.nokiaN = ua.indexOf('nokiaN') &gt; -1; // windows mobile if (system.win == 'CE') &#123; system.winMobile = system.win; &#125; else if (system.win == 'Ph') &#123; if (/Windows Phone OS (\\d+.\\d)/i.test(ua)) &#123; system.win = 'Phone'; system.winMobile = parseFloat(RegExp['$1']); &#125; &#125; // 检测IOS版本 if (system.mac &amp;&amp; ua.indexOf('Mobile') &gt; -1) &#123; if (/CPU (?:iPhone )?OS (\\d+_\\d+)/i.test(ua)) &#123; system.ios = parseFloat(RegExp['$1'].replace('_', '.')); &#125; else &#123; system.ios = 2; // 不能真正检测出来，所以只能猜测 &#125; &#125; // 检测Android版本 if (/Android (\\d+\\.\\d+)/i.test(ua)) &#123; system.android = parseFloat(RegExp['$1']); &#125; // 游戏系统 system.wii = ua.indexOf('Wii') &gt; -1; system.ps = /PlayStation/i.test(ua); return &#123; engine: engine, browser: browser, system: system &#125;&#125;(); (注：原文摘自《JavaScript高级程序设计》第3版，第9章 客户端检测，9.3用户代理检测，p221)","categories":[],"tags":[{"name":"Front-End","slug":"Front-End","permalink":"https://blog.afacat.com/tags/Front-End/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.afacat.com/tags/JavaScript/"}]},{"title":"navigator，JS检测浏览器插件","slug":"navigator，JS检测浏览器插件","date":"2015-01-24T03:26:00.000Z","updated":"2019-06-29T10:47:04.000Z","comments":true,"path":"2015/01/24/navigator，JS检测浏览器插件/","link":"","permalink":"https://blog.afacat.com/2015/01/24/navigator，JS检测浏览器插件/","excerpt":"","text":"最早由Netscape Navigator 2.0引入的navigator对象，现在已经成为识别客户端浏览器的事实标准。虽然其它浏览器也通过其它方式提供了相同或相似的信息（例如，IE中的window.clientInformation和Opera中的window.opera），但navigator对象却是所有支持JavaScript的浏览器所共有的。与其它BOM对象的情况一样，每个浏览器中的navigator对象也都有一套自己的属性。下表列出了存在于所有浏览器中的属性和方法，以及支持它们的浏览器版本。 属性或方法 说明 IE FireFox Safari/Chrome Opera appCodeName 返回浏览器的名称，通常是Mozilla，即使在非Mozilla浏览器中也是如此 3.0+ 1.0+ 1.0+ 7.0+ appMinorVersion 次版本信息 4.0+ - - 9.5+ appName 完整的浏览器名称 3.0+ 1.0+ 1.0+ 7.0+ appVersion 浏览器的版本，一般不与实际的浏览器版本对应 3.0+ 1.0+ 1.0+ 7.0+ buildID 浏览器的编译版本 - 2.0+ - - cookieEnabled 表示cookie是否启用 4.0+ 1.0+ 1.0+ 7.0+ cpuClass 客户端计算机中使用的CPU类型（x86、68K、Alpha、PPC或other） 4.0+ - - - javaEnabled 表示当前浏览器中是否启用了java 4.0+ 1.0+ 1.0+ 7.0+ language 浏览器的主语言 - 1.0+ 1.0+ 7.0+ mimeType 在浏览器中注册的MIME类型数组 4.0+ 1.0+ 1.0+ 7.0+ onLine 表示浏览器是否连接到因特网 4.0+ 1.0+ - 9.5+ opsProfile 似乎早就不用了，查不到相关文档 4.0+ - - - oscpu 客户端计算机使用的操作系统或使用的CPU - 1.0+ - - platform 浏览器所在的系统平台 4.0+ 1.0+ 1.0+ 7.0+ plugins 浏览器中安装的插件信息的数组 4.0+ 1.0+ 1.0+ 7.0+ preference() 设置用户的首选项 - 1.5+ - - product 产品名称（如Gecko） - 1.0+ 1.0+ - productSub 关于产品的次要信息（如Gecko的版本） - 1.0+ 1.0+ - registerContentHandler() 针对特定的MIME类型将一个站点注册为处理程序 - 2.0 - - registerProtocolHandler() 针对特定协议将一个站点注册为处理程序 - 2.0 - - securityPolicy 已经废弃。安全策略的名称。为了与Netscape Navigator 4向后兼容而保留下来 - 1.0+ - - systemLanguage 操作系统的语言 4.0+ - - - taintEnabled 已经废弃。表示是否允许变量被修改(taint)。为了与Netscape Navigator 3向后兼容而保留下来 4.0+ 1.0+ - 7.0 userAgent 浏览器的用户代理字符串 3.+ 1.0+ 1.0+ 7.0+ userLanguage 操作系统的默认语言 4.0+ - - 7.0+ userProfile 借以访问用户个人信息的对象 4.0+ - - - vendor 浏览器的品牌 - 1.0+ 1.0+ - vendorSub 有关供应商的次要信息 - 1.0+ 1.0+ - 表中的这些navigator对象的属性通常用于检测显示网页的浏览器类型。 检测插件检测浏览器中是否安装了特定的插件是一种最常见的检例程。对于非IE浏览器可以使用plugins数组达到这个目的。该数组中的每一项都包含下列属性。name: 插件名字description: 插件的描述filename: 插件的文件名length: 插件所处理的MIME类型数量一般来说，name属性中会包含检测插件必需的所有信息，但有时候也不完全如此。在检测插件时，需要像下面这样循环迭代每个插件并将插件的name与给定的名字进行比较。 1234567891011121314/** * 检测浏览器中是否存在此插件（在IE中无效） * @param 插件名 name * @return boolean 存在插件返回true，否则返回false */function hasPlugin (name) &#123; name = name.toLowerCase(); for (var i = 0; i &lt; navigator.plugins.length; i++) &#123; if (navigator.plugins[i].name.toLowerCase().indexOf(name) &gt; -1) &#123; return true; &#125; &#125; return false;&#125; 而检测IE中的插件比较麻烦，因为IE不支持Netscape式的插件。在IE中检测插件的唯一方式就是使用专有的ActiveXObject类型，并尝试创建一个特定插件的实例。IE是以COM对象的方式实现插件的，而COM对象使用唯一标识符来标识。因此，要想检查特定的插件，就必须知道其COM标识符。例如，Flash的标识符是ShockwaveFlash.ShockwaveFlash。知道唯一标识符之后，就可以编写类似下面的函数来检测IE中是否安装相应的插件了。 12345678910111213/** * 检测IE中的插件 * @param 插件名 name * @return boolean 存在插件返回true，否则返回false */function hasIEPlugin (name) &#123; try &#123; new ActiveXObject(name); return true; &#125; catch (ex) &#123; return false; &#125;&#125; 鉴于检测这两种插件的方法差别太大，因此典型的做法是针对每个插件分别创建检测函数，而不是使用前面介绍的通用检测方法。来看下面的例子。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 检测浏览器中是否存在此插件（在IE中无效） * @param 插件名 name * @return boolean 存在插件返回true，否则返回false */function hasPlugin (name) &#123; name = name.toLowerCase(); for (var i = 0; i &lt; navigator.plugins.length; i++) &#123; if (navigator.plugins[i].name.toLowerCase().indexOf(name) &gt; -1) &#123; return true; &#125; &#125; return false;&#125;/** * 检测IE中的插件 * @param 插件名 name * @return boolean 存在插件返回true，否则返回false */function hasIEPlugin (name) &#123; try &#123; new ActiveXObject(name); return true; &#125; catch (ex) &#123; return false; &#125;&#125;// 检测所有浏览器中的Flashfunction hasFlash () &#123; // return hasPlugin(\"Flash\") || hasIEPlugin(\"ShockwaveFlash.ShockwaveFlash\"); var result = hasPlugin(\"Flash\"); if (!result) &#123; result = hasIEPlugin(\"ShockwaveFlash.ShockwaveFlash\"); &#125; return result;&#125;// 检测所有浏览器中的QuickTimefunction hasQuickTime () &#123; // return hasPlugin(\"QuickTime\") || hasIEPlugin(\"QuickTime.QuickTime\"); var result = hasPlugin(\"QuickTime\"); if (!result) &#123; reseult = hasIEPlugin(\"QuickTime.QuickTime\"); &#125; return result;&#125;alert(hasFlash()); // 检测浏览器是否有Flash插件alert(hasQuickTime()) // 检测浏览器是否有QuickTime插件 （注：本文摘自：《JavaScript高级程序设计》第3版，第8章，8.3 navigator对象 p210）","categories":[],"tags":[{"name":"Front-End","slug":"Front-End","permalink":"https://blog.afacat.com/tags/Front-End/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.afacat.com/tags/JavaScript/"}]},{"title":"location将地址栏参数拆分成键值对的对象","slug":"location将地址栏参数拆分成键值对的对象","date":"2015-01-23T06:02:00.000Z","updated":"2019-06-29T10:40:04.000Z","comments":true,"path":"2015/01/23/location将地址栏参数拆分成键值对的对象/","link":"","permalink":"https://blog.afacat.com/2015/01/23/location将地址栏参数拆分成键值对的对象/","excerpt":"","text":"window.location可获取地址栏的一系列信息，并且每个浏览器都支持该属性，非常方便。而获取到的问号后面的参数可以进行加工转变成我们所想要的键值对。 location的属性： 属性名 例子 说明 hash “#contents” 返回URL的hash（#后跟零或多个字符），如果URL中不包含散列，则返回空字符串 host “www.wrox.com:80” 返回服务器名称和端口号（如果有） hostname “www.wrox.com” 返回不带端口号的服务器名称 href “http://www.wrox.com” 返回当前加载页面的完整URL。而location对象的toString()方法也返回这个值 pathname “WileyCDA” 返回URL中的目录或文件名 port “8080” 返回URL中指定的端口号。如果URL中不包含端口号则返回空字符串 protocol “http:” 返回页面的使用协议。通常是http:或https: search “?q=javascript” 返回URL的查询字符串，这个字符串以问号开头 而修改了其中的任何属性，都会使得页面刷新，当然页面刷新还有其它方式。 location刷新123456location.assign(url); // 跳转链接location.href = url; // 跳转链接window.location = url; // 跳转链接location.replace(url); // 链接链接，不保存于历史纪录location.reload(); // 刷新，从缓存中读取location.reload(true); // 刷新，重新从服务器读取 获取地址栏的参数，并以键值对展现123456789101112131415161718192021222324function getQueryStringArgs() &#123; var qs = (location.search.length &gt; 0 ? location.search.substring(1) : \"\"), args = &#123;&#125;, items = qs.length ? qs.split(\"&amp;\") : [], item = null, name = null, value = null, i = 0, len = items.length; for (i = 0; i &lt; len; i++) &#123; item = items[i].split(\"=\"); // decodeURIComponent解码 name = decodeURIComponent(item[0]); value = decodeURIComponent(item[1]); if (name.length) &#123; args[name] = value; &#125; &#125; return args;&#125; 通过调用getQueryStringArgs()方法就可以返回地址栏中的参数信息，并保存于对象中。","categories":[],"tags":[{"name":"Front-End","slug":"Front-End","permalink":"https://blog.afacat.com/tags/Front-End/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.afacat.com/tags/JavaScript/"}]},{"title":"Ubuntu下搭建LAMP配置讲解","slug":"Ubuntu下搭建LAMP配置讲解","date":"2014-12-30T09:42:00.000Z","updated":"2019-06-29T10:34:02.000Z","comments":true,"path":"2014/12/30/Ubuntu下搭建LAMP配置讲解/","link":"","permalink":"https://blog.afacat.com/2014/12/30/Ubuntu下搭建LAMP配置讲解/","excerpt":"","text":"LAMP（Linux, Apache, Mysql, PHP），顾名思义，要在Ubuntu下搭建LAMP环境时，需要先下载Apache, Mysql, PHP。 安装apache21$sudo apt-get install apache2 （然后可通过sudo /etc/init.d/apache2 restart重启服务器，当然可以把restart改为start/stop对应启动与关闭） 安装php1$ sudo apt-get install libapache2-mod-php5 php5 装完之后写一个测试程序。先执行命令 1$ sudo gedit /var/www/test.php 在/var/www/目录下创建test.php的测试文件，然后test.php如下： 123&lt;?hp echo \"Hello, World!\";&gt; 完成之后保存，再到浏览器中输入http://localhost/test.php，若浏览器能输入&quot;Hello, World!”则表示php安装成功 安装mysql1sudo apt-get install mysql-server mysql-client apt-get将会自动下载最新mysql，安装过程中，mysql会提示输入mysql的密码。于是，mysql就这样安装好了，是不是比windows下安装mysql快，方便100倍？附mysql启动、关闭、重启命令： 1$ sudo /etc/init.d/mysql start 其中start改为stop/restart代表停止/重启完成之后需要设置/var/www的下的权限，不然会提示权限不足 1$ sudo chmod -R 777 /var/www 其中-R表示递归，即所有的子目录设置同样的权限。777是最高权限，所有的用户可读可写，可根据需要自行修改对应权限。 就这样LAMP轻松的在Ubuntu下搭建好了。 那如何更改apache的根目录/var/www呢？只需要将/etc/apache2/apache.conf下的Directory中的/var/www更改为自己的路径（注意：此路径只能是/var/www下的子路径） 12345&lt;Directory /var/www/html/&gt; # 此处进行了修改 Options Indexes FollowSymLinks AllowOverride None Require all granted&lt;/Directory&gt;","categories":[],"tags":[{"name":"Back-End","slug":"Back-End","permalink":"https://blog.afacat.com/tags/Back-End/"},{"name":"PHP","slug":"PHP","permalink":"https://blog.afacat.com/tags/PHP/"},{"name":"Linux","slug":"Linux","permalink":"https://blog.afacat.com/tags/Linux/"},{"name":"Apache","slug":"Apache","permalink":"https://blog.afacat.com/tags/Apache/"}]},{"title":"PHP jpgraph的一点小提示（附安装方法）","slug":"PHP-jpgraph的一点小提示（附安装方法）","date":"2014-11-10T07:29:00.000Z","updated":"2019-06-29T10:24:56.000Z","comments":true,"path":"2014/11/10/PHP-jpgraph的一点小提示（附安装方法）/","link":"","permalink":"https://blog.afacat.com/2014/11/10/PHP-jpgraph的一点小提示（附安装方法）/","excerpt":"","text":"PHP中的GD库本身是一套很强大的绘图库了，绘制的图像基本可以满足日常要求，但强大规强大，还是不够方便哈，因为强大方便的基于PHP的GD库的jpgraph也就诞生啦！ PHP默认是不启用GD库的，因为需要在php.ini的配置文件中将extension=php_gd2.dll注释打开。打开后你就可以画一些你想画的各种奇葩图案了。什么？不会画？那回去学基础！ 今天看了一下某培训机构的视频，看了jpgraph报表这块儿，按照视频方法，在http://jpgraph.net/download/上下载了Version: 3.0.7版本，解压后在Examples目录下创建一个jpgraph目录，并将src目录下的除开Examples的所有文件剪切到Examples目录下刚创建的jpgraph目录内。然后把Examples拷贝到apache所配置的目录即可。 可是结果试了半天，老报错： 123456789Warning: strftime(): It is not safe to rely on the system's timezone settings. You are *required* to use the date.timezone setting or the date_default_timezone_set() function. In case you used any of those methods and you are still getting this warning, you most likely misspelled the timezone identifier. We selected the timezone 'UTC' for now, but please set date.timezone to select your timezone. in H:\\TestFile\\Examples\\jpgraph\\jpgraph.php on line 391JpGraph Error: HTTP headers have already been sent.Caused by output from file jpgraph.php at line 392.Explanation:HTTP headers have already been sent back to the browser indicating the data as text before the library got a chance to send it's image HTTP header to this browser. This makes it impossible for the library to send back image data to the browser (since that would be interpretated as text by the browser and show up as junk text).Most likely you have some text in your script before the call to Graph::Stroke(). If this texts gets sent back to the browser the browser will assume that all data is plain text. Look for any text, even spaces and newlines, that might have been sent back to the browser.For example it is a common mistake to leave a blank line before the opening \"&lt;?php\". 上面的Warning报了一堆后，出现了一个错误：JpGraph Error，于是乎，英文不好的博主索性将这堆英文拉到百度翻译去，索性还是没看懂，网上找了一堆也是无人答之，后在Google下搜一下才找到。http://bbs.php100.com/simple/?t294044.html ，答案大概就是时区什么什么问题的，也给出了解决方案用date_default_timezone_set(‘Asia/Chongqing’);设置对应的时区即可，这里设置成了重庆。问题也就随之解决了。 随后又下载了Version: 3.5.0b1的jpgraph，按同样的方法试之，首页的图片还是加载不出来，原因是没有‘jpgraph/jpgraph_odo.php’这个文件，导致引入时就出了问题，而博主到网上搜了相应的文件也复制到jpgraph目录下，也还是未能解决，最后不了了之。 有解决方法否？","categories":[],"tags":[{"name":"Back-End","slug":"Back-End","permalink":"https://blog.afacat.com/tags/Back-End/"},{"name":"PHP","slug":"PHP","permalink":"https://blog.afacat.com/tags/PHP/"}]},{"title":"PHP文件上传后缀名与文件类型对照表","slug":"PHP文件上传后缀名与文件类型对照表","date":"2014-11-08T01:24:00.000Z","updated":"2019-06-29T09:34:47.000Z","comments":true,"path":"2014/11/08/PHP文件上传后缀名与文件类型对照表/","link":"","permalink":"https://blog.afacat.com/2014/11/08/PHP文件上传后缀名与文件类型对照表/","excerpt":"","text":"左边为IE， 右边为Firefox id 后缀名 php识别出的文件类型 id 后缀名 php识别出的文件类型 0 gif image/gif 0 gif image/gif 1 jpg image/jpeg 1 jpg image/pjpeg 2 png image/png 2 png image/x-png 3 bmp image/bmp 3 bmp image/bmp 4 psd application/octet-stream 4 psd application/octet-stream 5 ico image/x-icon 5 ico image/x-icon 6 rar application/octet-stream 6 rar application/octet-stream 7 zip application/zip 7 zip application/x-zip-compressed 8 7z application/octet-stream 8 7z application/octet-stream 9 exe application/octet-stream 9 exe application/octet-stream 10 avi video/avi 10 avi video/avi 11 rmvb application/vnd.rn-realmedia-vbr 11 rmvb application/vnd.rn-realmedia-vbr 12 3gp application/octet-stream 12 3gp application/octet-stream 13 flv application/octet-stream 13 flv application/octet-stream 14 mp3 audio/mpeg 14 mp3 audio/mpeg 15 wav audio/wav 15 wav audio/wav 16 krc application/octet-stream 16 krc application/octet-stream 17 lrc application/octet-stream 17 lrc application/octet-stream 18 txt text/plain 18 txt text/plain 19 doc application/msword 19 doc application/msword 20 xls application/vnd.ms-excel 20 xls application/vnd.ms-excel 21 ppt application/vnd.ms-powerpoint 21 ppt application/vnd.ms-powerpoint 22 pdf application/pdf 22 pdf application/pdf 23 chm application/octet-stream 23 chm application/octet-stream 24 mdb application/msaccess 24 mdb application/msaccess 25 sql application/octet-stream 25 sql text/plain 26 con application/octet-stream 26 con application/octet-stream 27 log text/plain 27 log text/plain 28 dat application/octet-stream 28 dat text/plain 29 ini application/octet-stream 29 ini application/octet-stream 30 php application/octet-stream 30 php application/octet-stream 31 html text/html 31 html text/html 32 ttf application/octet-stream 32 ttf application/octet-stream 33 fon application/octet-stream 33 fon application/octet-stream 34 js application/x-javascript 34 js text/html 35 xml text/xml 35 xml text/xml 36 dll application/octet-stream 36 dll application/octet-stream 37 dll application/octet-stream 37 class application/java","categories":[],"tags":[{"name":"Back-End","slug":"Back-End","permalink":"https://blog.afacat.com/tags/Back-End/"},{"name":"PHP","slug":"PHP","permalink":"https://blog.afacat.com/tags/PHP/"}]},{"title":"PHP生成验证码","slug":"PHP生成验证码","date":"2014-11-04T10:41:00.000Z","updated":"2019-06-29T09:08:05.000Z","comments":true,"path":"2014/11/04/PHP生成验证码/","link":"","permalink":"https://blog.afacat.com/2014/11/04/PHP生成验证码/","excerpt":"","text":"验证码已经是现在网站中非常基础的知识点了，验证码的存在可以防止恶意破解密码、刷票、灌水，可以有效的防止暴力破解特定用户。 现在就来了解了解那些年PHP中屌屌的验证码吧。 首先，以四位验证码为例（多位验证码一样的道理）。 目前网站大多仍然采用静态图片验证码，因为这样实现起来简单又方便，不需要过硬的功底，当然这也是基础。而其原理也就是通过PHP的画图功能将文字画成图片返回到页面。因此，我们解决的问题也就只有三步而已： 随机生成验证码的内容将验证码转换成图片，即绘图将所绘出的图返回到页面中 当然，PHP默认是没有开启绘图功能的，因此，在php.ini的配置文件中先开启绘图功能吧：搜到 ;extension=php_gd2.dll 将前面的分号去掉即可。（记得保存喔！） 那根据第一点，大家首先应该会想到数字的验证码，因为这容易，随机生成个几个数字，然后拼起来也就行了，像酱紫！ 12345$validateCode = '';for ($i = 0; $i &lt; 4; $i ++) &#123; $validateCode .= rand(0, 9);&#125;echo $validateCode; 然后仔细想想，现在的网站验证码都有字母，可这玩意儿都没字母，怎么呢？然后又想到，直接把上面那玩意儿搞成十六进制就好了。 12345$validateCode = '';for ($i = 0; $i &lt; 4; $i ++) &#123; $validateCode .= dechex(rand(0, 16));&#125; echo $validateCode; 好像有点自作聪明的赶脚呀，不过想想，也算是有几个字母了，可却只有a,b,c,d,e,f，那要是需要所有字母咋办呢？哈哈，在想想也就想到把所有的字母和数字等在一个字符串中列出来，然后通过随机下标的形式去随机获取对应的值，也就成了这样： 123456$validateCode = '';$str = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890';for ($i = 0; $i &lt; 4; $i ++) &#123; $validateCode .= $str[rand(0, strlen($str))];&#125; echo $validateCode; 哈哈，终于像验证码里的随机数了，不过看到下面的方法，有总瞬间被秒的赶脚呀： 1echo substr(str_shuffle('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890'), 0, 4); str_shuffle方法将字符串内容打乱，substr($str, 0, 4)取到了前四个数。这样是完全没有问题的！不过细心的看的出来，这样的验证码里的内容是不会重复的。 以上验证码也就产生了，接下来也就要将验证码用PHP画出来了。 123456789101112131415$validateCode = substr(str_shuffle('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890'), 0, 4);// 创建一张宽为110px，高为25px的图片$img = imagecreatetruecolor(110, 25);// 将图片的背景颜色设置成黑色，颜色值分别对应RGB$bgcolor = imagecolorallocate($img, 0, 0, 0);// 创建白色$white = imagecolorallocate($img, 255, 255, 255);// 添加文字在图片中，第二个参数为文字的大小，只能在1~5，第三个参数为x坐标，第4个参数为y坐标，第5个参数为文字的内容，第6个参数为文字的颜色imagestring($img, rand(3, 5), rand(0, 80), rand(2, 10), $validateCode, $white);// 添加文字在图片中，第二个参数为文字的大小，只能在1~5，第三个参数为x坐标，第4个参数为y坐标，第5个参数为文字的内容，第6个参数为文字的颜色imagestring($img, rand(3, 5), rand(0, 80), rand(2, 10), $validateCode, $white); 当然，这样的话验证码就太好识别了，就只是单纯的黑底白字，为了增加点难度，我们就多加几条线叠加在验证码的上面。 12345678910111213141516171819202122$validateCode = substr(str_shuffle('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890'), 0, 4);// 创建一张宽为110px，高为25px的图片$img = imagecreatetruecolor(110, 25);// 将图片的背景颜色设置成黑色，颜色值分别对应RGB$bgcolor = imagecolorallocate($img, 0, 0, 0);// imagefill($img, 10, 10, $bgcolor);// 创建白色$white = imagecolorallocate($img, 255, 255, 255);for ($i = 0; $i &lt; 30; $i ++) &#123; // 在图片上画线，其中第2个参数表示线的x起始坐标，第3个参数表示线的y起始坐标，第4个参数表示x的终止坐标，第5个参数表示y的终止坐标，第6个参数表示颜色，此处生成一个随机颜色 imageline($img, rand(0, 110), rand(0, 50), rand(0, 110), rand(0, 50), imagecolorallocate($img, rand(0, 255), rand(0, 255), rand(0, 255)));&#125;// 添加文字在图片中，第二个参数为文字的大小，只能在1~5，第三个参数为x坐标，第4个参数为y坐标，第5个参数为文字的内容，第6个参数为文字的颜色imagestring($img, rand(3, 5), rand(0, 80), rand(2, 10), $validateCode, $white);// 返回成图片header('Content-type: image/png');imagepng($img); 结果也就成了这样，当然，要想实现验证码，这样还是不够滴，需要通过将验证码生成的随机数存到服务器的session中，$_SESSION[&#39;validate&#39;] = $validateCode;然后在通过客户端输入的验证码与之对比即可。PHP中屌屌的验证码也就这样实现了，当然，前面也说过了，这是最基础的代码，可以通过你的想法将其改变为实现算术的验证码，中文的验证码，或其它一些有趣的验证码，以减少其枯燥性又实现安全性。 大家有没有什么其它屌屌的验证码分享与我呢？","categories":[],"tags":[{"name":"Back-End","slug":"Back-End","permalink":"https://blog.afacat.com/tags/Back-End/"},{"name":"PHP","slug":"PHP","permalink":"https://blog.afacat.com/tags/PHP/"}]},{"title":"原生JavaScript生成GUID","slug":"原生JavaScript生成GUID","date":"2014-09-04T09:59:00.000Z","updated":"2019-06-29T08:58:28.000Z","comments":true,"path":"2014/09/04/原生JavaScript生成GUID/","link":"","permalink":"https://blog.afacat.com/2014/09/04/原生JavaScript生成GUID/","excerpt":"","text":"GUID（全局统一标识符）是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。通常平台会提供生成GUID的API。生成算法很有意思，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字。GUID的唯一缺陷在于生成的结果串会比较大。 GUID的格式为：xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx 大家都知道GUID在前端开发中用处不大，但如果需要插入某个ID，并且这个ID与后台对应等其它需要GUID的操作时，为了方便，我们还是可以生成一个GUID的。 一般在sql、java、C#等后台或数据库语言中生成GUID都很简单，而前端没有直接生成GUID的方法，只能自己手写一个。但由于GUID需要获取以太网卡的地址、以及纳秒级的时间等数字。而前端获取到这些信息比较困难（知道的童鞋请一定告诉我），而我们可以模拟实现生成GUID，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/* * 功能：生成一个GUID码，其中GUID以14个以下的日期时间及18个以上的16进制随机数组成，GUID存在一定的重复概率，但重复概率极低，理论上重复概率为每10ms有1/(16^18)，即16的18次方分之1，重复概率低至可忽略不计 * 免责声明：此代码为作者学习专用，如在使用者在使用过程中因代码问题造成的损失，与作者没有任何关系 * 日期：2014年9月4日 * 作者：wyc * http://www.cnblogs.com/wuyuchang */ function GUID() &#123; this.date = new Date(); /* 判断是否初始化过，如果初始化过以下代码，则以下代码将不再执行，实际中只执行一次 */ if (typeof this.newGUID != 'function') &#123; /* 生成GUID码 */ GUID.prototype.newGUID = function() &#123; this.date = new Date(); var guidStr = ''; sexadecimalDate = this.hexadecimal(this.getGUIDDate(), 16); sexadecimalTime = this.hexadecimal(this.getGUIDTime(), 16); for (var i = 0; i &lt; 9; i++) &#123; guidStr += Math.floor(Math.random()*16).toString(16); &#125; guidStr += sexadecimalDate; guidStr += sexadecimalTime; while(guidStr.length &lt; 32) &#123; guidStr += Math.floor(Math.random()*16).toString(16); &#125; return this.formatGUID(guidStr); &#125; /* * 功能：获取当前日期的GUID格式，即8位数的日期：19700101 * 返回值：返回GUID日期格式的字条串 */ GUID.prototype.getGUIDDate = function() &#123; return this.date.getFullYear() + this.addZero(this.date.getMonth() + 1) + this.addZero(this.date.getDay()); &#125; /* * 功能：获取当前时间的GUID格式，即8位数的时间，包括毫秒，毫秒为2位数：12300933 * 返回值：返回GUID日期格式的字条串 */ GUID.prototype.getGUIDTime = function() &#123; return this.addZero(this.date.getHours()) + this.addZero(this.date.getMinutes()) + this.addZero(this.date.getSeconds()) + this.addZero( parseInt(this.date.getMilliseconds() / 10 )); &#125; /* * 功能: 为一位数的正整数前面添加0，如果是可以转成非NaN数字的字符串也可以实现 * 参数: 参数表示准备再前面添加0的数字或可以转换成数字的字符串 * 返回值: 如果符合条件，返回添加0后的字条串类型，否则返回自身的字符串 */ GUID.prototype.addZero = function(num) &#123; if (Number(num).toString() != 'NaN' &amp;&amp; num &gt;= 0 &amp;&amp; num &lt; 10) &#123; return '0' + Math.floor(num); &#125; else &#123; return num.toString(); &#125; &#125; /* * 功能：将y进制的数值，转换为x进制的数值 * 参数：第1个参数表示欲转换的数值；第2个参数表示欲转换的进制；第3个参数可选，表示当前的进制数，如不写则为10 * 返回值：返回转换后的字符串 */ GUID.prototype.hexadecimal = function(num, x, y) &#123; if (y != undefined) &#123; return parseInt(num.toString(), y).toString(x); &#125; else &#123; return parseInt(num.toString()).toString(x); &#125; &#125; /* * 功能：格式化32位的字符串为GUID模式的字符串 * 参数：第1个参数表示32位的字符串 * 返回值：标准GUID格式的字符串 */ GUID.prototype.formatGUID = function(guidStr) &#123; var str1 = guidStr.slice(0, 8) + '-', str2 = guidStr.slice(8, 12) + '-', str3 = guidStr.slice(12, 16) + '-', str4 = guidStr.slice(16, 20) + '-', str5 = guidStr.slice(20); return str1 + str2 + str3 + str4 + str5; &#125; &#125;&#125; 只需要将其保存在一个JS文件中并引用即可。 然后我们只需要如下即可获取GUID码。 12var guid = new GUID();alert(guid.newGUID()); 实现原理很简单，这里只是采用了系统时间与18个以上的十六进制随机数组成，并用系统时间转换为十六进制，这样虽然还是有可能重复，但是重复的概率极低，可忽略不计。 以上为本人写的生成GUID的方法，如有更好的方法可以告诉我，谢谢！","categories":[],"tags":[{"name":"Front-End","slug":"Front-End","permalink":"https://blog.afacat.com/tags/Front-End/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.afacat.com/tags/JavaScript/"}]},{"title":"清除css、javascript及背景图在浏览器中的缓存","slug":"清除css、javascript及背景图在浏览器中的缓存","date":"2014-08-29T15:03:00.000Z","updated":"2019-06-29T08:55:20.000Z","comments":true,"path":"2014/08/29/清除css、javascript及背景图在浏览器中的缓存/","link":"","permalink":"https://blog.afacat.com/2014/08/29/清除css、javascript及背景图在浏览器中的缓存/","excerpt":"","text":"在实际项目开发过过程中，页面是上传到服务器上的。而为了减少服务器的压力，让用户少加载，浏览器会将图片、css、js缓存到本地中，以便下次访问网站时使用。这样做不仅减少了服务器的压力，并且也减少了用户的下载次数，获得更好的用户体验。 然而在版本升级或做一些css、js等调整的时候，缓存导致用户无法显示更新后的样式，这是另人头头疼的问题。除非用户自行手动升级缓存，不过几乎所有用户不会为了正常访问这个网站而去手动清除缓存，因为用户根本不知道是不是缓存的问题，而归根结底，用户就是认为你的页面存在问题，不能正常访问。 为了可以正常使用缓存，又避免这样的问题，我们可以动脑筋想想，如果解决此问题呢？ 如果更改了样式不能正常访问，那么更改样式的文件名呢？答案是可以的，这里将不再验证。然而每次都手动的去更改文件名显然过于麻烦，能不能不更改文件名呢？答案是肯定的。我们可能通在引入的文件名后面加入版本号，与之前的版本都不同的版本号（一般为更新日期）。代码如下： 12&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"reset.css?v=20140829\"&gt;&lt;script type=\"text/javascript\" src=\"core.js?v=20140829\"&gt;&lt;/script&gt; 可以看到我的CSS文件名及JS文件名后面都跟了”v=20140829“，这样做可以不去改变文件名又做到缓存的同时，可以实时更新。而”v=20140829“只是普遍习惯书写，可更改为其它的。 最后是图片，一般img标签的图片都不会重名，因为都是在后台生成的文件名。而如果是固定的文件名图片，方法同上。而对于背景图，由于更改了样式名，图片的解析路径自然是更新同步，因此背景图也更新了。","categories":[],"tags":[{"name":"Front-End","slug":"Front-End","permalink":"https://blog.afacat.com/tags/Front-End/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.afacat.com/tags/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"https://blog.afacat.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"https://blog.afacat.com/tags/HTML/"}]},{"title":"JavaScript获取浏览器内核","slug":"JavaScript获取浏览器内核","date":"2014-08-17T06:34:00.000Z","updated":"2019-06-29T08:51:10.000Z","comments":true,"path":"2014/08/17/JavaScript获取浏览器内核/","link":"","permalink":"https://blog.afacat.com/2014/08/17/JavaScript获取浏览器内核/","excerpt":"","text":"大家应该还记得JavaScript行内样式怎么写吧？（看来我是废话了！） 在前端开发过程中，有时我们需要判断浏览器的内核前缀，对不同的浏览器做出不同的处理，因此我们可以这么做。 alert(element.style.webkitTransition); 这个是获取以webkit为前缀的transition值。但如果不是webkit为前缀的浏览器，则会返回undefined。而我们可以将所有的内核前缀给枚举出来，然后获取其某个CSS的值，即可做出判断。代码如下： 123456789101112131415function getVendorPrefix() &#123; // 使用body是为了避免在还需要传入元素 var body = document.body || document.documentElement, style = body.style, vendor = ['webkit', 'khtml', 'moz', 'ms', 'o'], i = 0; while (i &lt; vendor.length) &#123; // 此处进行判断是否有对应的内核前缀 if (typeof style[vendor[i] + 'Transition'] === 'string') &#123; return vendor[i]; &#125; i++; &#125;&#125; 然后只需要调用getVendorPrefix()即可知道浏览器的内核前缀，如果返回undefined则证明浏览器不支持CSS3属性，即没有内核前缀。 大家应该知道，我们在写代码的过程中，能写CSS就不写JavaScritp，毕竟CSS的性能会比自己写JS的高一些，因此，我们在开发一些实际应该中，会用到transition，比如一个简单的图片轮播，我们可以使用CSS3的transition，也可以使用jQuery的animate或自己写原生，但CSS3的性能肯定会高一些，因此我们可以写两套代码，对于支持CSS3的浏览器则使用animation，而不支持的则使用计时器或animate。这样的话能够获取更好的用户体验。 以上是看jquery.slides.js的插件心得，如有更好的方法，请一定告知笔者。","categories":[],"tags":[{"name":"Front-End","slug":"Front-End","permalink":"https://blog.afacat.com/tags/Front-End/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.afacat.com/tags/JavaScript/"}]},{"title":"面向对象JS基础讲解: JavaScript原型链","slug":"JavaScript原型链","date":"2014-08-16T14:11:00.000Z","updated":"2019-06-29T10:09:07.000Z","comments":true,"path":"2014/08/16/JavaScript原型链/","link":"","permalink":"https://blog.afacat.com/2014/08/16/JavaScript原型链/","excerpt":"","text":"说好的讲解JavaScript继承，可是迟迟到现在讲解。废话不多说，直接进入正题。 既然你想了解继承，证明你对JavaScript面向对象已经有一定的了解，如还有什么不理解的可以参考《面向对象JS基础讲解: JavaScript原型》，接下来讲一般通过那些方法完成JavaScript的继承。 原型链JavaScript中实现继承最简单的方式就是使用原型链，将子类型的原型指向父类型的实例即可，即“子类型.prototype = new 父类型();”，实现方法如下： 123456789101112131415161718192021222324252627282930313233343536373839// 为父类型创建构造函数function SuperType() &#123; this.name = ['wuyuchang', 'Jack', 'Tim']; this.property = true;&#125;// 为父类型添加方法SuperType.prototype.getSuerperValue = function() &#123; return this.property;&#125;// 为子类型创建构造函数function SubType() &#123; this.test = ['h1', 'h2', 'h3', 'h4']; this.subproperty = false;&#125;// 实现继承的关键步骤，子类型的原型指向父类型的实例SubType.prototype = new SuperType();// 在此处给子类型添加方法，一定要在实现继承之后，否则会在将指针指向父类型的实例，则方法为空SubType.prototype.getSubValue = function() &#123; return this.subproperty;&#125;/* 以下为测试代码示例 */var instance1 = new SubType();instance1.name.push('wyc');instance1.test.push('h5');alert(instance1.getSuerperValue()); // truealert(instance1.getSubValue()); // falsealert(instance1.name); // wuyuchang,Jack,Tim,wycalert(instance1.test); // h1,h2,h3,h4,h5var instance2 = new SubType();alert(instance2.name); // wuyuchang,Jack,Tim,wycalert(instance2.test); // h1,h2,h3,h4 可以看到如上的代码就是通过原型链实现的一个简单的继承，但看到测试代码示例中还是存在些问题。相信看了我的博文《面向对象JS基础讲解: JavaScript原型》的童鞋一定知道原型链代码存在的第一个问题是由于子类型的原型是父类型的实例，也就是子类型的原型中包含的父类型的属性，从而导致引用类型值的原型属性会被所有实例所共享。以上代码的instance1.name.push(&#39;wyc&#39;);就可以证明此问题的存在。而原型链的第二个问题就是：在创建子类型的实例时，不能向超类型的构造函数中传递参数。因此我们在实际开发中，很少单独使用原型链。 借用构造函数为了解决原型链中存在的两个问题，开发人员开始使用一种叫做借用构造函数的技术来解决原型链中存在的问题。这种技术的实现思路也挺简单，只需要在子类型的构造函数内调用父类型的构造函数即可。别忘了，函数只不过是在特定环境中执行代码的对象，因此可以通过apply()或call()方法执行构造函数。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 为父类型创建构造函数function SuperType(name) &#123; this.name = name; this.color = ['pink', 'yellow']; this.property = true; this.testFun = function() &#123; alert('https://blog.afacat.com/'); &#125;&#125;// 为父类型添加方法SuperType.prototype.getSuerperValue = function() &#123; return this.property;&#125;// 为子类型创建构造函数function SubType(name) &#123; SuperType.call(this, name); this.test = ['h1', 'h2', 'h3', 'h4']; this.subproperty = false;&#125;// 在此处给子类型添加方法，一定要在实现继承之后，否则会在将指针指向父类型的实例，则方法为空SubType.prototype.getSubValue = function() &#123; return this.subproperty;&#125;/* 以下为测试代码示例 */var instance1 = new SubType(['wuyuchang', 'Jack', 'Nick']);instance1.name.push('hello');instance1.test.push('h5');instance1.color.push('blue');instance1.testFun(); // https://blog.afacat.com/alert(instance1.name); // wuyuchang,Jack,Nick,hello// alert(instance1.getSuerperValue()); // error 报错alert(instance1.test); // h1,h2,h3,h4,h5 alert(instance1.getSubValue()); // false alert(instance1.color); // pink,yellow,bluevar instance2 = new SubType('wyc');instance2.testFun(); // https://blog.afacat.com/alert(instance2.name); // wyc // alert(instance2.getSuerperValue()); // error 报错alert(instance2.test); // h1,h2,h3,h4alert(instance2.getSubValue()); // falsealert(instance2.color); // pink,yellow 可以看到以上代码中子类型SubType的构造函数内通过调用父类型”SuperType.call(this, name);“，从而实现了属性的继承，也可以在子类型创建实例的时候为父类型传递参数了，但新的问题又来了。可以看到我在父类型的构造函数中定义了一个方法：testFun，在父类型的原型中定义了一个方法：getSuperValue。可是在实例化子类型后仍然是无法调用父类型的原型中定义的方法getSuperValue，只能调用父类型中构造函数的方法：testFun。这就同创建对象中只使用构造函数模式一样，使得函数没有复用性可言。考虑到这些问题，借用构造函数的技术也是很少单独使用的。 组合继承（原型链+借用构造函数）顾名思义，组合继承就是结合使用原型链与借用构造函数的优点，组合而成的一个模式。实现也很简单，既然是结合，那当然结合了两方的优点，即原型链继承方法，而在构造函数继承属性。具体代码实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 为父类型创建构造函数function SuperType(name) &#123; this.name = name; this.color = ['pink', 'yellow']; this.property = true; this.testFun = function() &#123; alert('https://blog.afacat.com/'); &#125;&#125;// 为父类型添加方法SuperType.prototype.getSuerperValue = function() &#123; return this.property;&#125;// 为子类型创建构造函数function SubType(name) &#123; SuperType.call(this, name); this.test = ['h1', 'h2', 'h3', 'h4']; this.subproperty = false;&#125;SubType.prototype = new SuperType();// 在此处给子类型添加方法，一定要在实现继承之后，否则会在将指针指向父类型的实例，则方法为空SubType.prototype.getSubValue = function() &#123; return this.subproperty;&#125;/* 以下为测试代码示例 */var instance1 = new SubType(['wuyuchang', 'Jack', 'Nick']);instance1.name.push('hello');instance1.test.push('h5');instance1.color.push('blue');instance1.testFun(); // https://blog.afacat.com/alert(instance1.name); // wuyuchang,Jack,Nick,helloalert(instance1.getSuerperValue()); // truealert(instance1.test); // h1,h2,h3,h4,h5 alert(instance1.getSubValue()); // false alert(instance1.color); // pink,yellow,bluevar instance2 = new SubType('wyc');instance2.testFun(); // https://blog.afacat.com/alert(instance2.name); // wyc alert(instance2.getSuerperValue()); // truealert(instance2.test); // h1,h2,h3,h4alert(instance2.getSubValue()); // falsealert(instance2.color); // pink,yellow 以上代码通过SuperType.call(this, name);继承父类型的属性，通过SubType.prototype = new SuperType();继承父类型的方法。以上代码很方便的解决了原型链与借用构造函数所遇到的问题，成为了JavaScript中最为常用的实例继承的方法。但混合模式也并非没有缺点，可以看到在以上代码中在继承方法的时候实际已经继承了父类型的属性，只不过此时对于引用类型属于共享的，因此在子类型的构造函数内在次调用父类型的构造函数从而继承了父类型的属性而去覆盖了原型中所继承的属性，这样调用两次构造函数显然没有必要，但有什么方法可以解决呢？在解决此问题时先看以下两个模式。 原型式继承原型式继承的的实现方法与普通继承的实现方法不同，原型式继承并没有使用严格意义上的构造函数，而是借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。具体代码如下： 12345function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125; 代码示例： 123456789101112131415161718192021/* 原型式继承 */function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;var person = &#123; name : 'wuyuchang', friends : ['wyc', 'Nicholas', 'Tim']&#125;var anotherPerson = object(person);anotherPerson.name = 'Greg';anotherPerson.friends.push('Bob');var anotherPerson2 = object(person);anotherPerson2.name = 'Jack';anotherPerson2.friends.push('Rose');alert(person.friends); // wyc,Nicholas,Tim,Bob,Rose 寄生式继承12345678/* 寄生式继承 */function createAnother(original) &#123; var clone = object(original); clone.sayHi = function() &#123; alert('hi'); &#125; return clone;&#125; 使用示例： 12345678910111213141516171819202122/* 原型式继承 */function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125; /* 寄生式继承 */function createAnother(original) &#123; var clone = object(original); clone.sayHi = function() &#123; alert('hi'); &#125; return clone;&#125;var person = &#123; name : 'wuyuchang', friends : ['wyc', 'Nicholas', 'Rose']&#125;var anotherPerson = createAnother(person);anotherPerson.sayHi(); 寄生组合式继承前面说过了JavaScrip中组合模式实现继承的缺点，现在我们就来解决它的缺点，实现思路是，对于构造函数继承属性，而原型链的混成形式继承方法，即不用在继承方法的时候实例化父类型的构造函数。代码如下： 123456789101112function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;/* 寄生组合式继承 */function inheritPrototype(subType, superType) &#123; var prototype = object(superType.prototype); prototype.constructor = subType; subType.prototype = prototype;&#125; 而在使用时只需要将组合模式中的“SubType.prototype = new SuperType();”这行代码替换成inheritPrototype(subType, superType);即可。寄生组合式继承的高效率体现在它只调用了一次父类型构造函数，避免了创建不必要的或多余的属性。与此同时，原型链还能保持不变，因此，还能够正常使用instanceof和isPrototypeof()。这也是目前来说最理想的继承方式了，目前也在向这种模式转型。（YUI也使用了这种模式。） 此博文参考《JavaScript高级程序设计第3版》，代码为经过改写，更具体，并加了注释使大家更易懂。如对JS继承方面有独到见解的童鞋不别吝啬，回复您的见解供大家参考！","categories":[],"tags":[{"name":"Front-End","slug":"Front-End","permalink":"https://blog.afacat.com/tags/Front-End/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.afacat.com/tags/JavaScript/"},{"name":"prototype","slug":"prototype","permalink":"https://blog.afacat.com/tags/prototype/"}]},{"title":"让IE6/7支持inline-block","slug":"让IE6支持inline-block","date":"2014-08-13T13:25:00.000Z","updated":"2019-06-29T08:35:09.000Z","comments":true,"path":"2014/08/13/让IE6支持inline-block/","link":"","permalink":"https://blog.afacat.com/2014/08/13/让IE6支持inline-block/","excerpt":"","text":"本来今天想出JavaScript继承的博文的，由于也才刚学习不久，以及工作比较忙，所以暂推两天写JavaScript的继承，喜欢的童鞋们关注我的博客哟！ okay，言归正传。之前在接触前端的时候，处理各种浏览器的兼容问题，现在也有了一定的积累，对IE系列的CSSbug也写了一篇博文，喜欢的童鞋可以点击此处查看。 inline-block是CSS2.1属性，而大家经常会这么处理ie6、7下的inline-block 12345.selector &#123; display: inline-block; *display: inline; *zoom: 1;&#125; 这样来说处理ie6、7的兼容就不会有问题，久而久之大家也就习惯了，觉得是ie6、7不支持inline-block属性而需要写个hack来改变他的显示方式，然而真的是这样吗？其实早在ie5.5就已经开始支持inline-block了，只是支持的并不是那么完善。可参考MSDN:http://msdn.microsoft.com/zh-cn/library/ie/ms530751(v=vs.85).aspx。接下来，作者将带大家来证明一下ie5.5以上的浏览器是否真的支持`inline-block`。 首先大家看下面这个例子： 123456789101112131415161718192021222324&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;style type=\"text/css\"&gt; html, body, div, span &#123;margin: 0; padding: 0&#125; .wrapper span &#123; display: inline-block; width: 100px; height: 100px; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"wrapper\"&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 可以看到，我为行元素&lt;span&gt;设置了display: inline-block;属性，结果如何呢？（由于作者的IETester出了点问题，IE5.5和IE7不能打开，因此我使用IETester打开IE6，用IE10的浏览器模式切换至IE7） 可以看到，身为行元素的&lt;span&gt;在IE6及IE7下神奇的可以设置宽高了，并且是在同一行（废话）。看来行元素在ie6、7是可以设置inline-block的，那么块元素呢？ 12345678910111213141516171819202122232425&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;style type=\"text/css\"&gt; html, body, div, span &#123;margin: 0; padding: 0&#125; .wrapper div &#123; display: inline-block; width: 100px; height: 100px; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"wrapper\"&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 可以看到块元素在IE6、7下是无法设置inline-block的，因此可以得出结论，IE6、IE7实际上是支持inline-block的，只是支持不那么全面。至于列表元素大家可以下去尝试一下&lt;li&gt;。因为我们才使用如下代码对块元素在IE6、7下使用inline-block做兼容处理。 1234567891011121314151617181920212223242526&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;style type=\"text/css\"&gt; html, body, div, span &#123;margin: 0; padding: 0&#125; .wrapper div &#123; display: inline-block; *display: inline; *zoom: 1; width: 100px; height: 100px; border: 1px solid #000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"wrapper\"&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 而此代码对行元素同样实用，因此不管三七二十一，上来直接display: inline-block; *display: inline; *zoom: 1;肯定不会有问题。这也导致了大家认为IE6、7是不支持inilne-block的一个误解。而实际上对于行元素，可以直接设置display: inline-block;不用再设置*zoom: 1; 其实细心的童鞋会发现设置inline-block后，其它浏览器会有几像素的缝隙，而在ie6、7下却没有，这是因为其它浏览器将回车或空格当成了一个空格，而形成了元素之前有空隙，可以将元素写在同一行就可解决此问题，有童鞋会说使用float: left;既然使用inline-block就已经解决了块元素在同一行，或行元素无法设置宽高的问题了就不要在使用float: left了，我记得w3c标准上也有说 display: inline-block不要和float: left同时使用。","categories":[],"tags":[{"name":"Front-End","slug":"Front-End","permalink":"https://blog.afacat.com/tags/Front-End/"},{"name":"IE-Support","slug":"IE-Support","permalink":"https://blog.afacat.com/tags/IE-Support/"},{"name":"CSS","slug":"CSS","permalink":"https://blog.afacat.com/tags/CSS/"}]},{"title":"面向对象JS基础讲解: JavaScript原型","slug":"JavaScript原型","date":"2014-08-12T15:33:00.000Z","updated":"2019-06-29T08:36:59.000Z","comments":true,"path":"2014/08/12/JavaScript原型/","link":"","permalink":"https://blog.afacat.com/2014/08/12/JavaScript原型/","excerpt":"","text":"什么是面向对象？面向对象是一种思想！（废话）。 面向对象可以把程序中的关键模块都视为对象，而模块拥有属性及方法。这样我们如果把一些属性及方法封装起来，日后使用将非常方便，也可以避免繁琐重复的工作。接下来将为大家讲解在JS中面向对象的实现。 工厂模式工厂模式是软件工程领域一种广为人知的设计模式，而由于在ECMAScript中无法创建类，因此用函数封装以特定接口创建对象。其实现方法非常简单，也就是在函数内创建一个对象，给对象赋予属性及方法再将对象返回即可。 1234567891011function createBlog(name, url) &#123; var o = new Object(); o.name = name; o.url = url; o.sayUrl= function() &#123; alert(this.url); &#125; return o;&#125;var blog1 = createBlog('wuyuchang', 'http://www.cnblogs.com/wuyuchang/'); 可以看到工厂模式的实现方法非常简单，解决了创建多个相似对象的问题，但是工厂模式却无从识别对象的类型，因为全部都是Object，不像Date、Array等，因此出现了构造函数模式。 构造函数模式ECMAScript中构造函数可以创建特定类型的对象，类似于Array、Date等原生JS的对象。其实现方法如下： 12345678910function Blog(name, url) &#123; this.name = name; this.url = url; this.alertUrl = function() &#123; alert(this.url); &#125;&#125;var blog = new Blog('wuyuchang', 'http://www.cnblogs.com/wuyuchang/');console.log(blog instanceof Blog); // true， 判断blog是否是Blog的实例，即解决了工厂模式中不能 这个例子与工厂模式中除了函数名不同以外，细心的童鞋应该发现许多不同之处： 函数名首写字母为大写 （虽然标准没有严格规定首写字母为大写，但按照惯例，构造函数的首写字母用大写 没有显示的创建对象 直接将属性和方法赋值给了this对象 没有return语句 使用new创建对象 能够识别对象（这正是构造函数模式胜于工厂模式的地方） 构造函数虽然好用，但也并非没有缺点，使用构造函数的最大的问题在于每次创建实例的时候都要重新创建一次方法（理论上每次创建对象的时候对象的属性均不同，而对象的方法是相同的），然而创建两次完全相同的方法是没有必要的，因此，我们可以将函数移到对象外面（也许有些童鞋已经看出缺点，嘘！）。 1234567891011121314function Blog(name, url) &#123; this.name = name; this.url = url; this.alertUrl = alertUrl;&#125;function alertUrl() &#123; alert(this.url);&#125;var blog = new Blog('wuyuchang', 'http://www.cnblogs.com/wuyuchang/'), blog2 = new Blog('cnblogs', 'http://www.cnblogs.com/');blog.alertUrl(); // http://www.cnblogs.com/wuyuchang/blog2.alertUrl(); // http://www.cnblogs.com/ 我们将alertUrl设置成全局函数，这样一来blog与blog2访问的都是同一个函数，可是问题又来了，在全局作用域中定义了一个实际只想让Blog使用的函数，显示让全局作用域有些名副其实，更让人无法接受的是在全局作用域中定义了许多仅供特定对象使用的方法，浪费空间不说，显然失去了面向对象封装性了，因此可以通过原型来解决此问题。 原型模式我们创建的每个函数都有prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。使用原型对象的好处就是可以让所有对象实例共享它所包含的属性及方法。 1234567891011121314151617181920212223function Blog() &#123;&#125;Blog.prototype.name = 'wuyuchang';Blog.prototype.url = 'http://www.cnblogs.com/wuyuchang/';Blog.prototype.friend = ['fr1', 'fr2', 'fr3', 'fr4'];Blog.prototype.alertInfo = function() &#123; alert(this.name + this.url + this.friend );&#125;// 以下为测试代码var blog = new Blog(), blog2 = new Blog();blog.alertInfo(); // wuyuchanghttp://www.cnblogs.com/wuyuchang/fr1,fr2,fr3,fr4blog2.alertInfo(); // wuyuchanghttp://www.cnblogs.com/wuyuchang/fr1,fr2,fr3,fr4blog.name = 'wyc1';blog.url = 'http://***.com';blog.friend.pop();blog2.name = 'wyc2';blog2.url = 'http://+++.com';blog.alertInfo(); // wyc1http://***.comfr1,fr2,fr3blog2.alertInfo(); // wyc2http://+++.comfr1,fr2,fr3 原型模式也不是没有缺点，首先，它省略了构造函数传递初始化参数这一环节，结果所有实例在默认情况下都取得了相同的属性值，这样非常不方便，但这还是不是原型的最大问题，原型模式的最大问题在于共享的本性所导致的，由于共享，因此因此一个实例修改了引用，另一个也随之更改了引用。因此我们通常不单独使用原型，而是结合原型模式与构造函数模式。 混合模式（原型模式 + 构造函数模式）12345678910111213141516function Blog(name, url, friend) &#123; this.name = name; this.url = url; this.friend = friend;&#125;Blog.prototype.alertInfo = function() &#123; alert(this.name + this.url + this.friend);&#125;var blog = new Blog('wuyuchang', 'http://www.cnblogs.com/wuyuchang/', ['fr1', 'fr2', 'fr3']), blog2 = new Blog('wyc', 'http://**.com', ['a', 'b']);blog.friend.pop();blog.alertInfo(); // wuyuchanghttp://www.cnblogs.com/wuyuchang/fr1,fr2blog2.alertInfo(); // wychttp://**.coma,b 混合模式中构造函数模式用于定义实例属性，而原型模式用于定义方法和共享属性。每个实例都会有自己的一份实例属性，但同时又共享着方法，最大限度的节省了内存。另外这种模式还支持传递初始参数。优点甚多。这种模式在ECMAScript中是使用最广泛、认同度最高的一种创建自定义对象的方法。 动态原型模式动态原型模式将所有信息封装在了构造函数中，而通过构造函数中初始化原型（仅第一个对象实例化时初始化原型），这个可以通过判断该方法是否有效而选择是否需要初始化原型。 123456789101112131415function Blog(name, url) &#123; this.name = name; this.url = url; if (typeof this.alertInfo != 'function') &#123; // 这段代码只执行了一次 alert('exe time'); Blog.prototype.alertInfo = function() &#123; alert(thia.name + this.url); &#125; &#125;&#125;var blog = new Blog('wuyuchang', 'http://www.cnblogs.com/wuyuchang'), blog2 = new Blog('wyc', 'http:***.com'); 可以看到上面的例子中只弹出一次窗，’exe time’，即当blog初始化时，这样做blog2就不在需要初始化原型，对于使用这种模式创建对象，可以算是perfect了。 此博文参考《JavaScript高级程序设计》第3版，但语言都经过简化，例子也重写过，如果有什么不懂的地方请留言回复，作者将更新博客。","categories":[],"tags":[{"name":"Front-End","slug":"Front-End","permalink":"https://blog.afacat.com/tags/Front-End/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.afacat.com/tags/JavaScript/"},{"name":"prototype","slug":"prototype","permalink":"https://blog.afacat.com/tags/prototype/"}]},{"title":"DOM2级事件兼容","slug":"DOM2级事件兼容","date":"2014-08-11T09:50:00.000Z","updated":"2019-06-29T10:20:00.000Z","comments":true,"path":"2014/08/11/DOM2级事件兼容/","link":"","permalink":"https://blog.afacat.com/2014/08/11/DOM2级事件兼容/","excerpt":"","text":"事件对象——兼容处理 12345678/* * 功能: 事件对象兼容 * 参数: 表示常规浏览器的事件对象e */function getEvent(e) &#123; // 如果存在e存在，直接返回，否则返回window.event return e || window.event;&#125; 获取事件所对应的目标——兼容处理 12345678/* * 功能: 获取事件所对应的目标 * 参数: 表示常规浏览器的事件对象e */function getTargetByEvent(e) &#123; // 如果存在e.target，直接返回，否则返回window.event.srcElement return e.target || window.event.srcElement;&#125; 添加事件——兼容处理 12345678/* * 功能: 添加事件 * 参数: */function addEventHandler(element, eventName, handler) &#123; // 三目(条件)运算符，如果存在document.addEventListener直接调用，否则调用document.attachEvent这个方法 document.addEventListener ? element.addEventListener(eventName, handler, flase) : element.attachEvent('on' + eventName, handler);&#125; 阻止默认事件——兼容处理 12345678/* * 功能: 阻止默认事件 * 参数: 表示要阻止的事件对象 */function stopDefaultEvent(e) &#123; // 三目(条件)运算符，如果存在e.preventDefault直接调用，否则使用window.event.returnValue = false; e.preventDefault ? e.preventDefault() : (window.event.returnValue = false);&#125; 阻止冒泡事件——兼容处理 1234567/* * 功能: 阻止冒泡事件 * 参数: 表示要阻止的事件对象 */function stopBubbleEvent(e) &#123; e.stopPropagation ? e.stopPropagation() : (window.event.cancelBubble = true);&#125; 以上为一些事件对象所涉及到的兼容处理。其实JS的兼容处理比较简单，无非就是判断浏览器是否有此方法(对象)，如果有的话，就直接调用(获取)，否则使用另外的方法。","categories":[],"tags":[{"name":"Front-End","slug":"Front-End","permalink":"https://blog.afacat.com/tags/Front-End/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.afacat.com/tags/JavaScript/"},{"name":"IE-Support","slug":"IE-Support","permalink":"https://blog.afacat.com/tags/IE-Support/"}]},{"title":"让IE6支持position:fixed的方法，CSS expression与JavaScript eval讲解","slug":"让IE6支持position-fixed的方法","date":"2014-08-11T09:50:00.000Z","updated":"2019-06-29T08:11:59.000Z","comments":true,"path":"2014/08/11/让IE6支持position-fixed的方法/","link":"","permalink":"https://blog.afacat.com/2014/08/11/让IE6支持position-fixed的方法/","excerpt":"","text":"做吸顶效果或是固定效果时，使用position:fixed无非是最方便的，可是万恶的IE6是没有fixed这个属性值的，而我们要使IE6能够像fixed一样固定在浏览器中的某个位置，使用onscroll改变top值是一个方法，但如果滚轮滚的快，会出现卡闪烁情况。而如高级浏览器如果也这样用，那显然有失大雅，除非JS中判断浏览器版本。但是在这里笔者要讲解的是使用CSS完成fixed效果。千言万语不及实例一个： 以上是笔者在IETester下测试IE6的fixed，注意看滚动条。其中导航采用的是position:fixed。核心代码如下： 1234567.nav &#123; /* nav为导航栏 */ position:fixed; _position: absolute; top:0; _top:expression(eval(documentElement.scrollTop)); background: #FAA;&#125; 使用到了hack技术，下划线所代表的属性只有IE6以下识别。（因为只有IE6以下不支持fixed，所以特殊处理）以上效果即可实现IE6下的fixed效果。而要理解_top:expression(eval(documentElement.scrollTop));不太容易，需要理解expression及eval的含义及用法，也是下面要讲解的内容。 expression为IE特有的属性，支持IE5及以上版本，用来在CSS中书写JavaScript代码，也就是说expression的括号内可以是一段JavaScript代码。 eval表示执行字符串内容的语句或表达式，并返回其结果。 用法：eval(codes); 参数： codes – 字符串形式的表达式或语句 返回值： 如果没有参数，返回undefined 如果有返回值将返回此值，否则返回undefined 如果为表达式，返回表达式的值 如果为语句返回语句的值 如果为多条语句或表达式返回最后一条语句的值 了解expression及eval后，_top:expression(eval(documentElement.scrollTop));就不难理解了。documentElement.scrollTop为IE下获取滚动条的位置，而top值就相当于滚动条距离顶部的位置。如果scrollTop值改变，_top也就相应改变。 而为什么要使用eval呢？因为documentElement.scrollTop实际就是一条语句，并没有返回值，相当于在JS中执行了a=1后没执行任何操作。而我们要拿到documentElement.scrollTop值就需要将其返回，而只需要使用eval即可。 这样一来，所有浏览器器都可以有fixed的效果了，但是你会发现IE6下滚动鼠标滚轮时仍然会出现闪烁现象，这是因为当滚动条滚动或浏览器大小改变时，IE6奇葩的渲染引擎会重置所有内容并重画页面，因此会出现振动或闪烁的问题。而使用backgroune-attachment:fixed;添加至html或body会强制页面重画前先加载CSS，因为重画前处理的CSS，也就是重画前你的表达式就已经改变了，不像之前的重画之后才改变。这样当你鼠标滚动的时候就不会出现闪烁的现象了。这样就完全达成了fixed的效果。代码如下：body { _background: url(about: blank) fixed} 总结：IE6下不能实现fixed，因此使用absolute模拟fixed，因此需要使用JS。而只针对IE6进行处理，可在CSS中通过IE特有的expresstion写JavaScript，从而实时改变top值达到模拟fixed的效果。而IE6滚动或调整浏览器大小则重载CSS，因此使用在body中使用background-attachment:fixed使页面重新渲染前加载CSS。 123456789101112131415161718192021body &#123;_background: url(about:blank) fixed&#125;.nav &#123; position: fixed; _position: absolute; top: 0; _top: expression(eval(documentElement.scrollTop)); // top值为想要固定定位的位置，设置left同理，设置right与bottom需要通过scrollLeft及scrollTop进行计算，如下注释 // 固定左：_left:expression(eval(documentElement.scrollLeft)); // 固定右：_left:expression(eval(documentElement.scrollLeft + documentElement.clientWidth - this.offsetWidth)); // 固定下：_top:expression(eval(documentElement.scrollTop + documentElement.clientHeight - this.offsetHeight));&#125; 以上就是IE6下解决fixed方法的完美方案。如有问题或疑问请留言。","categories":[],"tags":[{"name":"Front-End","slug":"Front-End","permalink":"https://blog.afacat.com/tags/Front-End/"},{"name":"IE-Support","slug":"IE-Support","permalink":"https://blog.afacat.com/tags/IE-Support/"},{"name":"CSS","slug":"CSS","permalink":"https://blog.afacat.com/tags/CSS/"}]},{"title":"JavaScript的DOM节点操作","slug":"JavaScript的DOM节点操作","date":"2014-08-11T09:44:00.000Z","updated":"2019-06-29T10:07:33.000Z","comments":true,"path":"2014/08/11/JavaScript的DOM节点操作/","link":"","permalink":"https://blog.afacat.com/2014/08/11/JavaScript的DOM节点操作/","excerpt":"","text":"DOM(Document Object Model/文档对象模型)是针对HTML和XML文档的一个API。DOM节点树：在文档中出现的空格、回车、标签、注释、文本、doctype、标签等都属于DOM节点。 操作DOM节点的方式无非就是：创建、添加(插入)、移除、替换、查找(获取)、克隆DOM节点。 操作 语法 创建文本节点 var newText = document.createTextNode(‘文本节点’); 创建标签节点 var newNode = document.createElement(‘div’); 添加(插入)子节点至末尾 父节点.appendChild(子节点); 添加(插入)子节点至某节点前 父节点.insertBefore(子节点, 某节点); 移除子节点 父节点.removeChild(子节点); 替换节点 父节点.replaceChild(替换后的节点, 替换前的节点); 查找(获取)所有子节点 父节点.childNodes 查找(获取)所有是标签类型的子节点 父节点.children 查找(获取)下一个兄弟节点 某节点.nextSibling 查找(获取)上一个兄弟节点 某节点.previousSibling 查找(获取)父节点 子节点.parentNode 查找(获取)第一个子节点 父节点.firstChild 查找(获取)最后一个子节点 父节点.lastChild 也可以使用document.get…的方法来获取，详细请看：JavaScript获取标签方法及兼容处理","categories":[],"tags":[{"name":"Front-End","slug":"Front-End","permalink":"https://blog.afacat.com/tags/Front-End/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.afacat.com/tags/JavaScript/"}]},{"title":"JavaScript获取渲染后的样式","slug":"JavaScript获取渲染后的样式","date":"2014-08-11T09:37:00.000Z","updated":"2019-06-29T09:58:55.000Z","comments":true,"path":"2014/08/11/JavaScript获取渲染后的样式/","link":"","permalink":"https://blog.afacat.com/2014/08/11/JavaScript获取渲染后的样式/","excerpt":"","text":"一般我们利用element.style.属性来获取CSS的样式，而此方法只能获取标签内的样式，无法获取头部或引入的样式，因此，而我们又需要获取其样式，则我们可以使用：（其中element为标签，proName为属性）document.defaultView.getComputedStyle(element)[proName]的方法获其样式，而此方法不支持IE6~IE8，因此我们针对IE8以下的使用element.currentStyle[proName] 我们可以通过下面方法使其兼容 123456789/* * 功能: 通过属性名获取传入标签渲染后的样式 * 参数: 第一个参数表示你想要获取其属性值的标签; 第二个参数表示你想要获取其属性值的属性名 * 返回值: 返回第一个参数标签里面的属性名为第二个参数的样式 */function getStyle(element, proName) &#123; // document.defaultView.getComputedStyle为标准浏览器方法，element.currentStyle兼容IE6~IE8 return document.defaultView ? document.defaultView.getComputedStyle(element)[proName] : element.currentStyle[proName];&#125;","categories":[],"tags":[{"name":"Front-End","slug":"Front-End","permalink":"https://blog.afacat.com/tags/Front-End/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.afacat.com/tags/JavaScript/"},{"name":"IE-Support","slug":"IE-Support","permalink":"https://blog.afacat.com/tags/IE-Support/"}]},{"title":"JavaScript获取标签方法及兼容处理","slug":"JavaScript获取标签方法及兼容处理","date":"2014-08-11T09:29:00.000Z","updated":"2019-06-29T09:55:54.000Z","comments":true,"path":"2014/08/11/JavaScript获取标签方法及兼容处理/","link":"","permalink":"https://blog.afacat.com/2014/08/11/JavaScript获取标签方法及兼容处理/","excerpt":"","text":"语法 支持程度 document.getElementById(‘Id名’); 所有浏览器 document.getElementsByTagName(‘标签名’); 所有浏览器 document.getElementsByName(‘name’); 所有浏览器 document.getElementsByClassName(‘类名’); 除ie9以下，均支持 如需通过类名获取标签，并兼容所有浏览器，则需做兼容处理： 12345678910111213141516171819202122232425/* * 功能: 通过类名获取一定范围内的标签数组 * 参数: 第一个参数表示获取的范围，若在整个文档搜索，则传入document; 第二个参数表示想要获取标签的类名 * 返回值: 第一个参数里的类名为第二个参数的标签数组 */function getElementsByClass(element, classStr) &#123; if(element.getElementsByClassName) &#123; // 如果浏览器有getElementsByClassName的方法，则直接使用 return element.getElementsByClassName(classStr); &#125; else &#123; // 否则先查找标签中类名为className的标签 var elements = element.getElementsByTagName('*'), arr = [], // 存放类名为className的标签 len = elements.length; for (var i = 0; i &lt; len; i++) &#123; if (elements[i].className == classStr) &#123; // 如果为所给类名，则放入数组 arr.push(elements[i]); &#125; &#125;; return arr; &#125;&#125;","categories":[],"tags":[{"name":"Front-End","slug":"Front-End","permalink":"https://blog.afacat.com/tags/Front-End/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.afacat.com/tags/JavaScript/"},{"name":"IE-Support","slug":"IE-Support","permalink":"https://blog.afacat.com/tags/IE-Support/"}]},{"title":"原生AJAX基础讲解及兼容处理","slug":"原生AJAX基础讲解及兼容处理","date":"2014-08-11T06:24:00.000Z","updated":"2019-06-29T09:51:01.000Z","comments":true,"path":"2014/08/11/原生AJAX基础讲解及兼容处理/","link":"","permalink":"https://blog.afacat.com/2014/08/11/原生AJAX基础讲解及兼容处理/","excerpt":"","text":"AJAX = Asynchronous JavaScript and XML (异步的JavaScript和XML)。 AJAX不是新技术 ，但却是热门的技术。它可以在不重载（刷新）整个页面的情况下与服务器进行数据交互并更新网页模块。 AJAX的优点有很多：可以局部刷新、按需加载，这样就减轻了服务器的数据流量。并且在页面更新的同时，用户可以浏览器网页的其它内容而不受影响，也减轻了结构负担。AJAX也不是万能的，在有以上优点的同时SEO也受到了影响。 在学习AJAX之前，必须先有HTML/XHTML、CSS、JavaScript/DOM的基础。 AJAX与服务器进行数据交互，必然涉及到服务器端，与此同时也就涉及到了服务器请求对象的创建(new XMLHttpRequest())、确认请求方式(open())、发送请求(send())以及响应请求(responseText)。 创建对象： IE9+及其它浏览器支持使用new XMLHttpRequest()的创建对象方式，而IE8及以下则使用new ActiveXObject()的方式进行创建。 看了网上许多人使用如下代码进行兼容： 123456789try &#123; xml = new ActiveXObject(\"Msxml2.XMLHTTP\");&#125; catch(e) &#123; try &#123; xml = new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125; catch(e1) &#123; xml = new XMLHttpRequest(); &#125;&#125; 笔者用IE11调试功能测试IE10及以下不写new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;)也是没问题的，于是在创建对象时可以使用代码： var xml = window.ActiveXObject ? new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;) : new XMLHttpRequest(); 确认请求： xml.open(&#39;get&#39;, &#39;url&#39;, true/false); 第一个参数表示：string. 访问方式，有两具值：get/post，大部分的时候使用get 第二个参数表示：string. 要连接的服务器网址 第三个参数表示：boolean. 表示是否需要异步请求（true为发起异步加载） 发送请求： xml.send(); 如果需要发送数据则采用xml.send(str); 响应数据： 12345 xml.onreadystatechange = function() &#123; if (xml.readyState == 4 &amp;&amp; xml.status == 200) &#123; alert(xml.responseText); &#125; &#125; status返回链接的状态，一般返回200与404，200表示成功返回，404表示未找到页面。 readyState有5个值，分别为：0、1、2、3、4。而每当值改变时都会触发一次onreadystatechange。 readyState的5个值含义分别为： 0: 请求未初始化1: 服务器连接已建立2: 请求已接收3: 请求处理中4: 请求已完成，且响应已就绪 也就是当请求完成，并且找到页面时，然后才获取服务器上的数据。","categories":[],"tags":[{"name":"Front-End","slug":"Front-End","permalink":"https://blog.afacat.com/tags/Front-End/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.afacat.com/tags/JavaScript/"}]},{"title":"JavaScript中apply与call的含义与区别","slug":"JavaScript中apply与call的含义与区别","date":"2014-08-10T15:57:00.000Z","updated":"2019-06-29T09:45:40.000Z","comments":true,"path":"2014/08/10/JavaScript中apply与call的含义与区别/","link":"","permalink":"https://blog.afacat.com/2014/08/10/JavaScript中apply与call的含义与区别/","excerpt":"","text":"JavaScript中，apply()与call()的含义一样，均为改变调用函数中的this指向。其中apply()与call()的第一个参数表示所要指向的对象，若调用函数无参数可不写，则默认为window。 第一个参数后的参数表示调用函数的参数，其中apply()第一个参数后面的参数为一个数组，call()第一个参数后面为0或多个参数。 例： 123456789101112131415161718192021222324window.x = 100;var obj = &#123;&#125;;obj.x = 1;obj.test = function(a) &#123; alert(this.x + 20 + a);&#125;var abc = &#123;&#125;;abc.x = 2;abc.test = function() &#123; alert(this.x + 30 + a);&#125;obj.test(10); // 结果为31,this指向objobj.test.call(window, 10); // 结果为130,this指向windowobj.test.call(abc, 10); // 结果为32,this指向abcobj.test.apply(window, [10]); // 结果为130,this指向windowobj.test.apply(abc, [10]) // 结果为32,this指向abc","categories":[],"tags":[{"name":"Front-End","slug":"Front-End","permalink":"https://blog.afacat.com/tags/Front-End/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.afacat.com/tags/JavaScript/"}]},{"title":"JavaScript子元素oumouseover触发父元素onmouseout","slug":"JavaScript子元素oumouseover触发父元素onmouseout","date":"2014-08-10T15:18:00.000Z","updated":"2019-06-29T09:44:00.000Z","comments":true,"path":"2014/08/10/JavaScript子元素oumouseover触发父元素onmouseout/","link":"","permalink":"https://blog.afacat.com/2014/08/10/JavaScript子元素oumouseover触发父元素onmouseout/","excerpt":"","text":"JavaScript中，父元素包含子元素： 当父级设置onmouseover及onmouseout时，鼠标从父级移入子级，则触发父级的onmouseout后又触发onmouseover从子级移入父级后再次触发父级的oumouseout后又触发onmouseover。而如果onmouseover内又应用了计时器便会存在较大的问题。下面针对此问题给出解决方案。 首先，在给出解决方案之前，必须先弄清楚几个对象及方法，分别如下： 1、事件对象 2、事件对象相关属性（只针对onmouseover及onmouseout），即fromElement、toElement、relatedTarget 3、判断一个元素是否包含另一个元素的方法，即element.contains(Node)与element.compareDocumentPosition(Node) 既然前面已经说了要弄清如上几个对象及方法，那么，我们就可以分析一下倒底如何去解决这个问题。分析： 存在的问题是设置onmouseover时，鼠标从移入父级内时，没任何问题，但由父级移入子级时，以及由子级称出到父级时会出现如上问题，那么我们可以想办法设置当鼠标从父级移入到子级时，或从子级移出到父级时让触发对象失效，我们可以通过if语句进行判断。而事件对象里面有个属性可以获取移入移出时的相关对象，下面就来介绍。 1、事件对象：可以获取事件对象的一系列属性，在事件中写一个参数，即可通过参数获取，方法如下 123wrap.onmouseover = function(e) &#123; e = window.event || e; // window.event是为了兼容ie下获取事件对象，而e为标准浏览器直接获取&#125; 2、事件对象的相关对象在触发onmouseover及onmouseout时，必定会涉及到其它对象，如：onmouseover的相关对象，即为哪个对象进入的。onmouseout的相关对象即为进入到哪个对象。获取方法如下： 12345678wrap.onmouseover = function(e) &#123; e = window.event || e; var s = e.fromElement || e.relatedTarget; //e.fromElement为IE下onmouseover获取相关对象方法，relatedTarget为标准浏览器下获取方法&#125;wrap.onmouseout = function(e) &#123; e = window.event || e; var s = e.toElement || e.relatedTarget; //e.toElementIE下onmouseout获取相关对象方法，relatedTarget为标准浏览器下获取方法&#125; 3、判断一个元素是否包含另一个元素IE下可以使用a.contains(b)判断a是否包含b标准浏览器下a.compareDocumentPosition(b)有5个值，若为0表示为同一节点，若为2表示a位于b后面，若为4表示a位于b前面，若为10表示a为b的后代，若为20表示a为b的祖级。 先上个即将用到的示例的HTML及CSS 123456789101112131415161718192021222324&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;style type=\"text/css\"&gt; html,body,div&#123;margin:0;padding:0&#125; .wrapper &#123; overflow: hidden; width: 800px; background: black; &#125; .box &#123; height: 200px; background: #FF0; margin: 80px 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"wrapper\" id=\"wrap\"&gt; &lt;div class=\"box\" id=\"box\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 既然知道了以上的获取属性及事件的必备方法，那么我们就可以想方法解决问题了当触发onmouseover时，可能是从对象以外移入的，也有可能是父级移入到子级，以及子级移出到父级，刚才也说过，onmouseover的相关对象是获取从哪个对象进入的。如果是从外面的对象进入的，我们就执行所需的代码。如果是从父级移入到子级或是由子级移出到父级时，则直接跳过。父级移入到子级对象，相关对象为父级。 子级移出到父级对象，相对对象为子级。代码如下： 1234567891011121314wrap.onmouseover = function(e) &#123; e = window.event || e; var s = e.fromElement || e.relatedTarget; if (document.all) &#123; //判断浏览器是否为IE,如果存在document.all则为IE if (!this.contains(s)) &#123; // 判断调用onmouseover的对象(this)是否包含自身或子级，如果包含，则不执行 console.log('IE will over'); &#125; &#125; else &#123; //标准浏览器下的方法 var reg = this.compareDocumentPosition(s); if (!(reg == 20 || reg == 0)) &#123; console.log('Browser will over'); &#125; &#125;&#125; 当触发onmouseout时，可能是从父级移到子级，也可能由子级移到父级，或是移出至父级之外。父级称到子级，则相关对象为子级，子级称到父级，则相关对象为父级。代码如下： 1234567891011121314wrap.onmouseout = function(e) &#123; e = window.event || e; var s = e.toElement || e.relatedTarget; if(document.all) &#123; if (!this.contains(s)) &#123; console.log('IE will out'); &#125; &#125; else &#123; var reg = this.compareDocumentPosition(s); if (!(reg == 20 || reg == 0)) &#123; console.log('Browser will out'); &#125; &#125;&#125; 问题也就得到了解决。 不过你会发现：onmouseover与onmouseout的判断方法其实是一样的。于是我们得到：无论是移入还是移出，只要相关对象是父级以外的就可以执行，否则代码不执行。 最后，再为大家提供本人自己写的兼容代码，复制到JS代码后可直接调用。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* * 功能：鼠标移入对象触发事件，兼容所有浏览器并防止鼠标在父子对象间移动造成的触发onmouseover的bug * 参数：第一个参数表示触发的对象，第二个参数表示触发的对象的事件对象，第三个对象表示要执行的函数 * 作者：http://www.cnblogs.com/wuyuchang/ */function mouseover(a, e, func) &#123; e = e || window.event; var b = e.fromElement || e.relatedTarget; mouseoverAndOut(a, b, func);&#125;/* * 功能：鼠标移出对象触发事件，兼容所有浏览器并防止鼠标在父子对象间移动造成的onmouseout的bug * 参数：第一个参数表示触发的对象，第二个参数表示触发的对象的事件对象，第三个对象表示要执行的函数 * 作者：http://www.cnblogs.com/wuyuchang/ */function mouseout(a ,e, func) &#123; e = e || window.event; var b = e.toElement || e.relatedTarget; mouseoverAndOut(a, b, func);&#125;/* * 功能：鼠标移入或移出对象触发事件，兼容所有浏览器并防止鼠标在父子对象间移动造成的onmouseover &amp; onmouseout的bug * 参数：第一个参数表示触发的对象，第二个参数表示触发的对象的事件对象，第三个对象表示要执行的函数 * 作者：http://www.cnblogs.com/wuyuchang/ */function mouseoverOrOut(a, e, func) &#123; e = e || window.event; var b; if (e.type == 'mouseover') &#123; b = e.fromElement || e.relatedTarget; &#125; else if (e.type == 'mouseout') &#123; b = e.toElement || e.relatedTarget; &#125; mouseoverAndOut(a, e, func);&#125;/* * 功能：鼠标移入或移出对象触发事件，兼容所有浏览器并防止鼠标在父子对象间移动造成的onmouseover &amp; onmouseout的bug * 参数：第一个参数表示触发的对象，第二个参数表示触发的对象的相关对象，第三个对象表示要执行的函数 * 作者：http://www.cnblogs.com/wuyuchang/ */function mouseoverAndOut(a, b, func) &#123; if (document.all) &#123; if (!(a.contains(b))) &#123; func(); &#125; &#125; else &#123; var res = a.compareDocumentPosition(b); if(!(res == 20 || res == 0))&#123; func(); &#125; &#125; &#125; （如果是onmouseover，调用mouseover(a, e, func)即可；如果是onmouseout，调用mouseout(a, e, func)即可；或不管onmouseover还是onmouseout直接调用mouseoverOrOut(a, e, func)即可。） 以上为个人经验之谈，如有不到之处还请留言指点。","categories":[],"tags":[{"name":"Front-End","slug":"Front-End","permalink":"https://blog.afacat.com/tags/Front-End/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.afacat.com/tags/JavaScript/"}]},{"title":"IE6常见bug","slug":"IE6常见bug","date":"2014-08-10T15:01:00.000Z","updated":"2019-06-29T09:34:04.000Z","comments":true,"path":"2014/08/10/IE6常见bug/","link":"","permalink":"https://blog.afacat.com/2014/08/10/IE6常见bug/","excerpt":"","text":"1、IE6怪异解析之padding与border算入宽高原因：未加文档声明造成非盒模型解析解决方法：加入文档声明&lt;!doctype html&gt; 2、IE6在块元素、左右浮动、设定marin时造成margin双倍（双边距）解决方法：display:inline 3、以下三种其实是同一种bug，其实也不算是个bug，举个例子：父标签高度20，子标签11，垂直居中，20-11=9，9要分给文字的上面与下面，怎么分？IE6就会与其它的不同，所以，尽量避免。 字体大小为奇数之边框高度少1px解决方法：字体大小设置为偶数或line-height为偶数 line-height，文本垂直居中差1px解决方法：padding-top代替line-height居中，或line-height加1或减1 与父标签的宽度的奇偶不同的居中造成1px的偏离解决方法：如果父标签是奇数宽度，则子标签也用奇数宽度;如果是父标签偶数宽度，则子标签也用偶数宽度 4、内部盒模型超出父级时，父级被撑大解决方法：父标签使用overflow:hidden 5、line-height默认行高bug解决方法：line-height设值 6、行标签之间会有一小段空白解决方法：float或结构并排(可读性差，不建议) 7、标签高度无法小于19px解决方法：overflow: hidden; 8、左浮元素margin-bottom失效解决方法：显示设置高度 or 父标签设置_padding-bottom代替子标签的margin-bottom or 再放个标签让父标签浮动，子标签margin-bottom，即(margin-bottom与float不同时作用于一个标签) 9、img于块元素中，底边多出空白解决方法：父级设置overflow: hidden; 或 img { display: block; } 或 _margin: -5px; 10、li之间会有间距解决方法：float: left; 11、块元素中有文字及右浮动的行元素，行元素换行解决方法：将行元素置于块元素内的文字前 12、position下的left，bottom错位解决方法：为父级(relative层)设置宽高或添加*zoom:1 13、子级中有设置position，则父级overflow失效解决方法：为父级设置position:relative 14、text-align:justify; text-align-last-justify; text-justify: distribute-all-line; 在最后一行没有生效解决方法：为父级设置显示的宽度，如width:100%","categories":[],"tags":[{"name":"Front-End","slug":"Front-End","permalink":"https://blog.afacat.com/tags/Front-End/"},{"name":"IE-Support","slug":"IE-Support","permalink":"https://blog.afacat.com/tags/IE-Support/"},{"name":"CSS","slug":"CSS","permalink":"https://blog.afacat.com/tags/CSS/"}]},{"title":"双飞翼布局","slug":"双飞翼布局","date":"2014-08-10T13:43:00.000Z","updated":"2019-06-29T08:12:04.000Z","comments":true,"path":"2014/08/10/双飞翼布局/","link":"","permalink":"https://blog.afacat.com/2014/08/10/双飞翼布局/","excerpt":"","text":"div+css早已是现在布局最常用的一种方式，可是布局又有许多种，因网站的功能、外表、适应人群而异，网站采用的布局也将是各式各样。常用的布局技术又有双飞翼布局、瀑布式布局、响应式布局等等，现实的前端开发中又常常不可能只用一门技术完成布局，往往需要多种技术相结合。而今天我将在这里为大家以最简单最直接的方式了解双飞翼布局。如果把双飞翼布局的左中右三栏看作是一只大鸟，那么可以把main看作是鸟的身体，left与right则可以理解为鸟的左翼与右翼。而此布局最重要的是将身体先对好，然后左翼与右翼移至身体的两侧。而其中我们经常使用浮动 float、负边距 negative margin与相对定位 relative position来完成各种布局。接下来我们来实现第一步：将身体摆好。 1234567891011121314151617&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt; 双飞翼布局&lt;/title&gt; &lt;meta charset=\"utf-8\"&gt; &lt;style&gt; .main&#123; width:100%; height:200px; background-color:black; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div class=\"main\"&gt;&lt;div&gt; &lt;/body&gt;&lt;/html&gt; 实现结果如下：（其中最要注意的是width:100%，即适应浏览器的变化而变化。不然也失去双飞翼的意义了。） 接下来来摆正双翼 123456789101112131415161718192021222324252627282930313233343536&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt; 双飞翼布局&lt;/title&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;style&gt; .main&#123; width:100%; height:200px; background-color:black; float:left; &#125; .left&#123; width:200px; height:200px; background-color:#faa; float:left; margin-left:-100%; &#125; .right&#123; width:200px; height:200px; background-color:#aaf; float:left; margin-left:-200px; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div class=\"main\"&gt;&lt;/div&gt; &lt;div class=\"left\"&gt;左&lt;/div&gt; &lt;div class=\"right\"&gt;右&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 结果如下： 上面可以看到，左右两翼中最重要的是将把margin-left设置成负边距(其实还有另一种方法可以不设置负边距)然后所有的都设置成浮动。最后，我们只需要要背上一点，双飞翼便“飞”了起来。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt; 双飞翼布局&lt;/title&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;style&gt; .main&#123; width:100%; height:200px; background-color:black; float:left; &#125; .left&#123; width:200px; height:200px; background-color:#faa; float:left; margin-left:-100%; &#125; .right&#123; width:200px; height:200px; background-color:#aaf; float:left; margin-left:-200px; &#125; .main-content&#123; height:200px; margin:0 200px 0 200px; background-color:#afa; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div class=\"main\"&gt; &lt;div class=\"main-content\"&gt;我是正文中的内容&lt;/div&gt; &lt;/div&gt; &lt;div class=\"left\"&gt;左&lt;/div&gt; &lt;div class=\"right\"&gt;右&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 结果如下： 上面看到最重要的是将main-content放在main里，我们也就可以在main中随意的写我们的内容了，而main-content是没有设置宽度的，有设置边距，这样我们就可以自适应浏览器的大小了。 以上就是双飞翼布局的最简单、最直接的书写方式了。而布局是没有任何限制的，没有一个布局可能通用网站，而掌握了最简单，最基础的布局方法，理解透彻了，其所有布局都能轻易掌握了，正所谓一通百通便是如此。","categories":[],"tags":[{"name":"Front-End","slug":"Front-End","permalink":"https://blog.afacat.com/tags/Front-End/"},{"name":"CSS","slug":"CSS","permalink":"https://blog.afacat.com/tags/CSS/"}]}]}